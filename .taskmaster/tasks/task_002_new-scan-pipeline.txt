# Task ID: 2
# Title: Integrate Bounded Queues with Backpressure
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Implement bounded queues between the file scanning (producer) and parsing (consumer) stages to manage memory and prevent overflow. Define and implement a 'wait' backpressure policy.
# Details:
Use `queue.Queue(maxsize=...)` to create a bounded queue with a sensible limit (e.g., 1000). The file scanner thread will put paths into this queue. The parser threads will get paths from it. The scanner should block ('wait' policy) when the queue is full, preventing it from outpacing the parsers and consuming excessive memory.

# Test Strategy:
Create a test scenario with a fast producer (scanner) and a slow consumer (mock parser with `time.sleep`). Verify that the queue fills up and the producer blocks, confirming that memory growth is constrained.

# Subtasks:
## 1. Integrate Bounded Queue into ScanParsePool [pending]
### Dependencies: None
### Description: Integrate a bounded queue.Queue into the ScanParsePool for producer-consumer pattern
### Details:
Modify the ScanParsePool to use a bounded queue.Queue for managing the flow of files between the scanner (producer) and parser (consumer) threads. Implement proper queue initialization and management.

## 2. Refactor Scanner as Producer [pending]
### Dependencies: None
### Description: Refactor the scanner to put items onto the bounded queue as a producer
### Details:
Modify the directory scanner to act as a producer that puts file paths onto the bounded queue. Implement proper error handling and queue management for the producer side.

## 3. Implement Parser Worker as Consumer [pending]
### Dependencies: None
### Description: Implement the parser worker to get items from the queue as a consumer
### Details:
Create parser worker threads that act as consumers, getting file paths from the bounded queue and processing them. Implement proper error handling and queue management for the consumer side.

