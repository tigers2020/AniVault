# AniVault v3 CLI - Packaging Deployment PRD

## Overview
Implement final packaging and deployment preparation including single executable creation, release artifacts, security compliance, and deployment verification. This ensures production-ready distribution.

## Goals
- Create single executable with PyInstaller/Nuitka
- Generate comprehensive release artifacts
- Implement security and compliance measures
- Ensure clean Windows execution
- Prepare for official release

## Success Criteria
- v1.0 tag created
- Clean Windows exe execution confirmed
- All release artifacts generated
- Security scanning completed
- Official release ready

## Technical Requirements

### Single Executable Packaging
- **PyInstaller primary**: `--onefile --console` build success
- **Nuitka fallback**: Alternative packaging option
- **Clean VM execution**: Windows 10/11 verification
- **Native module bundling**: anitopy, cryptography validation
- **Dependency resolution**: All dependencies bundled correctly

### Release Artifacts
- **Executable**: `anivault.exe` single file
- **Licenses**: Third-party license files
- **Schemas**: JSON schema files
- **Documentation**: User and API documentation
- **Release notes**: CHANGELOG.md
- **SBOM**: Software bill of materials
- **Integrity**: SHA256SUMS verification

### Security and Compliance
- **Code signing**: Optional Authenticode signing
- **SmartScreen**: Windows SmartScreen compatibility
- **License compliance**: Third-party license tracking
- **Vulnerability scanning**: Security scan results
- **SBOM generation**: CycloneDX SBOM creation

### Deployment Verification
- **Clean installation**: No external dependencies
- **Performance benchmarks**: Target hardware testing
- **User acceptance**: User acceptance testing
- **Compatibility**: Windows version compatibility
- **Documentation**: Complete user documentation

## Deliverables
- [ ] **Single executable packaging:**
  - [ ] PyInstaller `--onefile --console` build success
  - [ ] Nuitka fallback option ready
  - [ ] Clean Windows 10/11 VM execution verified
  - [ ] Native module bundling validation (anitopy, cryptography)
- [ ] **Release artifacts:**
  - [ ] `anivault.exe` single executable
  - [ ] `LICENSES/` third-party license files
  - [ ] `schemas/` JSON schema files
  - [ ] `docs/` documentation
  - [ ] `CHANGELOG.md` release notes
  - [ ] `SBOM.json` software bill of materials
  - [ ] `SHA256SUMS` file integrity verification
- [ ] **Security and compliance:**
  - [ ] Code signing (optional)
  - [ ] SmartScreen/AV whitelist guidance
  - [ ] Third-party license compliance
  - [ ] Vulnerability scanning results
- [ ] **Deployment verification:**
  - [ ] Clean Windows installation testing
  - [ ] No external dependencies required
  - [ ] Performance benchmarks on target hardware
  - [ ] User acceptance testing

## Definition of Done
- [ ] v1.0 tag created
- [ ] Clean Windows exe execution confirmed
- [ ] All release artifacts generated
- [ ] Security scanning completed
- [ ] Official release ready
- [ ] Performance benchmarks met
- [ ] User acceptance testing passed

## Single Executable Packaging Implementation

### PyInstaller Configuration
```python
# pyinstaller_config.py
import PyInstaller.__main__
import sys
from pathlib import Path

def build_executable():
    """Build single executable with PyInstaller."""
    args = [
        'src/cli/main.py',
        '--onefile',
        '--console',
        '--name=anivault',
        '--distpath=dist',
        '--workpath=build',
        '--specpath=specs',
        '--clean',
        '--noconfirm',
        '--add-data=schemas;schemas',
        '--add-data=LICENSES;LICENSES',
        '--hidden-import=anitopy',
        '--hidden-import=cryptography',
        '--hidden-import=tmdbv3api',
        '--hidden-import=rich',
        '--hidden-import=click',
        '--collect-all=anitopy',
        '--collect-all=cryptography',
        '--collect-all=tmdbv3api',
        '--collect-all=rich',
        '--collect-all=click'
    ]

    PyInstaller.__main__.run(args)

if __name__ == '__main__':
    build_executable()
```

### Nuitka Fallback Configuration
```python
# nuitka_config.py
import subprocess
import sys

def build_with_nuitka():
    """Build executable with Nuitka as fallback."""
    args = [
        'nuitka',
        '--onefile',
        '--console',
        '--output-filename=anivault.exe',
        '--output-dir=dist',
        '--include-data-dir=schemas=schemas',
        '--include-data-dir=LICENSES=LICENSES',
        '--include-module=anitopy',
        '--include-module=cryptography',
        '--include-module=tmdbv3api',
        '--include-module=rich',
        '--include-module=click',
        '--assume-yes-for-downloads',
        'src/cli/main.py'
    ]

    subprocess.run(args, check=True)

if __name__ == '__main__':
    build_with_nuitka()
```

### Build Script
```python
# build.py
import subprocess
import sys
from pathlib import Path

def main():
    """Main build script with fallback options."""
    print("Building AniVault v3 CLI...")

    # Try PyInstaller first
    try:
        print("Attempting PyInstaller build...")
        subprocess.run([sys.executable, 'pyinstaller_config.py'], check=True)
        print("PyInstaller build successful!")
        return True
    except subprocess.CalledProcessError as e:
        print(f"PyInstaller build failed: {e}")

    # Fallback to Nuitka
    try:
        print("Attempting Nuitka build...")
        subprocess.run([sys.executable, 'nuitka_config.py'], check=True)
        print("Nuitka build successful!")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Nuitka build failed: {e}")

    print("All build methods failed!")
    return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)
```

## Release Artifacts Implementation

### Release Artifact Generator
```python
import shutil
import hashlib
import json
from pathlib import Path
from datetime import datetime

class ReleaseArtifactGenerator:
    def __init__(self, version: str, build_dir: Path):
        self.version = version
        self.build_dir = build_dir
        self.release_dir = Path('releases') / f'anivault-{version}'

    def generate_release_artifacts(self):
        """Generate all release artifacts."""
        self.release_dir.mkdir(parents=True, exist_ok=True)

        # Copy executable
        self.copy_executable()

        # Generate license files
        self.generate_license_files()

        # Copy schemas
        self.copy_schemas()

        # Generate documentation
        self.generate_documentation()

        # Generate changelog
        self.generate_changelog()

        # Generate SBOM
        self.generate_sbom()

        # Generate checksums
        self.generate_checksums()

    def copy_executable(self):
        """Copy executable to release directory."""
        exe_source = self.build_dir / 'anivault.exe'
        exe_dest = self.release_dir / 'anivault.exe'
        shutil.copy2(exe_source, exe_dest)

    def generate_license_files(self):
        """Generate third-party license files."""
        licenses_dir = self.release_dir / 'LICENSES'
        licenses_dir.mkdir(exist_ok=True)

        # Copy license files from dependencies
        self.copy_dependency_licenses(licenses_dir)

    def copy_schemas(self):
        """Copy JSON schema files."""
        schemas_dir = self.release_dir / 'schemas'
        schemas_dir.mkdir(exist_ok=True)

        # Copy schema files
        for schema_file in Path('schemas').glob('*.json'):
            shutil.copy2(schema_file, schemas_dir)

    def generate_documentation(self):
        """Generate user documentation."""
        docs_dir = self.release_dir / 'docs'
        docs_dir.mkdir(exist_ok=True)

        # Copy documentation files
        for doc_file in Path('docs').glob('*.md'):
            shutil.copy2(doc_file, docs_dir)

    def generate_changelog(self):
        """Generate changelog from git history."""
        changelog_file = self.release_dir / 'CHANGELOG.md'

        # Generate changelog content
        changelog_content = self.create_changelog_content()

        with open(changelog_file, 'w', encoding='utf-8') as f:
            f.write(changelog_content)

    def generate_sbom(self):
        """Generate Software Bill of Materials."""
        sbom_file = self.release_dir / 'SBOM.json'

        # Generate SBOM using CycloneDX
        self.create_sbom(sbom_file)

    def generate_checksums(self):
        """Generate SHA256 checksums."""
        checksums_file = self.release_dir / 'SHA256SUMS'

        with open(checksums_file, 'w', encoding='utf-8') as f:
            for file_path in self.release_dir.rglob('*'):
                if file_path.is_file():
                    checksum = self.calculate_sha256(file_path)
                    relative_path = file_path.relative_to(self.release_dir)
                    f.write(f"{checksum}  {relative_path}\n")

    def calculate_sha256(self, file_path: Path) -> str:
        """Calculate SHA256 checksum for file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
```

## Security and Compliance Implementation

### Code Signing
```python
import subprocess
from pathlib import Path

class CodeSigner:
    def __init__(self, certificate_path: Path, password: str):
        self.certificate_path = certificate_path
        self.password = password

    def sign_executable(self, exe_path: Path):
        """Sign executable with Authenticode certificate."""
        try:
            subprocess.run([
                'signtool', 'sign',
                '/f', str(self.certificate_path),
                '/p', self.password,
                '/t', 'http://timestamp.digicert.com',
                '/d', 'AniVault v3 CLI',
                '/du', 'https://github.com/your-org/anivault',
                str(exe_path)
            ], check=True)
            print(f"Successfully signed {exe_path}")
        except subprocess.CalledProcessError as e:
            print(f"Code signing failed: {e}")
```

### Security Scanning
```python
class SecurityScanner:
    def __init__(self):
        self.scan_results = {}

    def run_security_scans(self):
        """Run comprehensive security scans."""
        # Run gitleaks
        self.scan_results['gitleaks'] = self.run_gitleaks()

        # Run trufflehog
        self.scan_results['trufflehog'] = self.run_trufflehog()

        # Run pip-audit
        self.scan_results['pip_audit'] = self.run_pip_audit()

        # Run bandit
        self.scan_results['bandit'] = self.run_bandit()

        return self.scan_results

    def generate_security_report(self) -> str:
        """Generate security scan report."""
        report = "# Security Scan Report\n\n"

        for scanner, results in self.scan_results.items():
            report += f"## {scanner.title()}\n\n"
            if results:
                report += f"```json\n{json.dumps(results, indent=2)}\n```\n\n"
            else:
                report += "No issues found.\n\n"

        return report
```

## Deployment Verification Implementation

### Clean Installation Testing
```python
class DeploymentVerifier:
    def __init__(self, exe_path: Path):
        self.exe_path = exe_path

    def test_clean_installation(self) -> bool:
        """Test clean Windows installation."""
        try:
            # Test basic execution
            result = subprocess.run([str(self.exe_path), '--help'],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                print("✓ Basic execution test passed")
                return True
            else:
                print(f"✗ Basic execution test failed: {result.stderr}")
                return False
        except subprocess.TimeoutExpired:
            print("✗ Execution timeout")
            return False
        except Exception as e:
            print(f"✗ Execution error: {e}")
            return False

    def test_dependency_requirements(self) -> bool:
        """Test that no external dependencies are required."""
        # Check if executable runs without Python installation
        # Check if all required libraries are bundled
        return True

    def test_performance_benchmarks(self) -> dict:
        """Test performance benchmarks on target hardware."""
        benchmarks = {
            'startup_time': self.measure_startup_time(),
            'memory_usage': self.measure_memory_usage(),
            'throughput': self.measure_throughput()
        }
        return benchmarks

    def measure_startup_time(self) -> float:
        """Measure application startup time."""
        import time
        start_time = time.time()
        subprocess.run([str(self.exe_path), '--help'],
                      capture_output=True, timeout=10)
        return time.time() - start_time
```

## Testing Requirements
- **Packaging testing**: PyInstaller and Nuitka builds
- **Artifact testing**: Release artifact generation
- **Security testing**: Code signing and scanning
- **Deployment testing**: Clean installation verification
- **Performance testing**: Benchmark validation

## Risk Mitigation
- **Build failures**: Multiple build options (PyInstaller/Nuitka)
- **Security issues**: Comprehensive security scanning
- **Compliance**: License and SBOM generation
- **Deployment issues**: Clean installation testing
- **Performance**: Benchmark validation

## Timeline
**Weeks 35-36**: Packaging deployment implementation
**Priority**: HIGH - Final packaging and release preparation

## Dependencies
- Requires completion of all Phase 1, 2, and 3 tags (1-12)
- File processing pipeline established
- TMDB API integration completed
- Cache system operational
- Rate limiting implemented
- CLI commands implemented
- Organize safety features completed
- Windows compatibility implemented
- Performance optimization completed
- Testing quality implemented
- Security configuration completed
- Logging monitoring completed
