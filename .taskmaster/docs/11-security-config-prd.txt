# AniVault v3 CLI - Security Configuration PRD

## Overview
Implement comprehensive security features and configuration management including API key encryption, configuration management, security scanning, and sensitive information handling. This ensures secure operation and data protection.

## Goals
- Implement Fernet symmetric encryption for API keys
- Create comprehensive configuration management system
- Integrate security scanning and vulnerability detection
- Implement sensitive information masking
- Ensure secure configuration storage

## Success Criteria
- Configuration save/decrypt E2E working
- `anivault.toml` example documentation completed
- Security scanning integrated into CI
- Sensitive information properly masked
- API key encryption working correctly

## Technical Requirements

### API Key Encryption
- **Fernet symmetric encryption**: PIN-based key storage
- **Cross-platform support**: Windows, Linux, macOS
- **Key rotation**: Migration and rotation support
- **Secure storage**: Encrypted configuration files
- **PIN protection**: User-defined PIN for key access

### Configuration Management
- **TOML configuration**: `anivault.toml` file structure
- **Environment variable priority**: ENV → exe_dir → user_home
- **Configuration validation**: Schema validation and error handling
- **Hot reloading**: Runtime configuration updates
- **Default values**: Sensible defaults for all settings

### Security Scanning
- **gitleaks integration**: Secret detection in code
- **trufflehog integration**: Advanced secret scanning
- **pip-audit**: Vulnerability scanning for dependencies
- **License compliance**: Third-party license tracking
- **SBOM generation**: Software bill of materials with CycloneDX

### Sensitive Information Handling
- **TMDB key masking**: API keys hidden in logs
- **User path masking**: Home directory path sanitization
- **Secure logging**: Sensitive data exclusion
- **Memory protection**: Secure memory handling
- **File permissions**: Secure configuration file permissions

## Deliverables
- [ ] **API key encryption:**
  - [ ] Fernet symmetric encryption with PIN
  - [ ] Cross-platform key storage
  - [ ] Key rotation and migration support
- [ ] **Configuration management:**
  - [ ] `anivault.toml` configuration file structure
  - [ ] Environment variable priority (ENV → exe_dir → user_home)
  - [ ] Configuration validation and error handling
- [ ] **Security scanning:**
  - [ ] gitleaks/trufflehog integration
  - [ ] pip-audit for vulnerability scanning
  - [ ] License compliance tracking
  - [ ] SBOM generation with CycloneDX
- [ ] **Sensitive information handling:**
  - [ ] TMDB key masking in logs
  - [ ] User home path prefix masking
  - [ ] Secure configuration storage

## Definition of Done
- [ ] Configuration save/decrypt E2E working
- [ ] `anivault.toml` example documentation completed
- [ ] Security scanning integrated into CI
- [ ] Sensitive information properly masked
- [ ] API key encryption working correctly
- [ ] Security scanning operational
- [ ] License compliance verified

## API Key Encryption Implementation

### Fernet Encryption
```python
from cryptography.fernet import Fernet
import base64
import os

class APIKeyManager:
    def __init__(self, pin: str):
        self.pin = pin
        self.key = self._derive_key(pin)
        self.fernet = Fernet(self.key)

    def _derive_key(self, pin: str) -> bytes:
        """Derive encryption key from PIN."""
        import hashlib
        salt = b'anivault_salt'  # Should be stored securely
        key = hashlib.pbkdf2_hmac('sha256', pin.encode(), salt, 100000)
        return base64.urlsafe_b64encode(key)

    def encrypt_api_key(self, api_key: str) -> str:
        """Encrypt API key for storage."""
        encrypted = self.fernet.encrypt(api_key.encode())
        return base64.urlsafe_b64encode(encrypted).decode()

    def decrypt_api_key(self, encrypted_key: str) -> str:
        """Decrypt API key for use."""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_key.encode())
        decrypted = self.fernet.decrypt(encrypted_bytes)
        return decrypted.decode()

    def store_api_key(self, api_key: str, config_path: Path):
        """Store encrypted API key in configuration."""
        encrypted_key = self.encrypt_api_key(api_key)

        config = {
            'tmdb': {
                'api_key_encrypted': encrypted_key,
                'encryption_version': '1.0'
            }
        }

        with open(config_path, 'w') as f:
            toml.dump(config, f)

    def load_api_key(self, config_path: Path) -> str:
        """Load and decrypt API key from configuration."""
        with open(config_path, 'r') as f:
            config = toml.load(f)

        encrypted_key = config['tmdb']['api_key_encrypted']
        return self.decrypt_api_key(encrypted_key)
```

### Cross-Platform Key Storage
```python
import platform
from pathlib import Path

class SecureConfigManager:
    def __init__(self):
        self.config_dir = self._get_config_dir()
        self.config_file = self.config_dir / 'anivault.toml'

    def _get_config_dir(self) -> Path:
        """Get platform-specific configuration directory."""
        system = platform.system()

        if system == 'Windows':
            return Path.home() / 'AppData' / 'Local' / 'AniVault'
        elif system == 'Darwin':  # macOS
            return Path.home() / 'Library' / 'Application Support' / 'AniVault'
        else:  # Linux
            return Path.home() / '.config' / 'anivault'

    def ensure_config_dir(self):
        """Ensure configuration directory exists with proper permissions."""
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # Set secure permissions (owner only)
        if platform.system() != 'Windows':
            os.chmod(self.config_dir, 0o700)
```

## Configuration Management Implementation

### TOML Configuration Structure
```toml
# anivault.toml
[project]
name = "AniVault"
version = "3.0.0"
description = "Anime file organization tool"

[tmdb]
api_key_encrypted = "encrypted_key_here"
encryption_version = "1.0"
base_url = "https://api.themoviedb.org/3"
timeout = 30

[rate_limiting]
requests_per_second = 35
burst_size = 50
retry_after_respect = true

[cache]
max_size_mb = 512
ttl_seconds = 2592000
lru_enabled = true

[logging]
level = "INFO"
file_rotation = true
max_file_size_mb = 20
backup_count = 5

[performance]
max_workers = 8
queue_size = 32
memory_limit_mb = 500
```

### Configuration Validation
```python
import toml
from pydantic import BaseModel, Field
from typing import Optional

class TMDBConfig(BaseModel):
    api_key_encrypted: str
    encryption_version: str = "1.0"
    base_url: str = "https://api.themoviedb.org/3"
    timeout: int = Field(default=30, ge=1, le=300)

class RateLimitingConfig(BaseModel):
    requests_per_second: int = Field(default=35, ge=1, le=100)
    burst_size: int = Field(default=50, ge=1, le=200)
    retry_after_respect: bool = True

class CacheConfig(BaseModel):
    max_size_mb: int = Field(default=512, ge=64, le=2048)
    ttl_seconds: int = Field(default=2592000, ge=3600, le=31536000)
    lru_enabled: bool = True

class AniVaultConfig(BaseModel):
    tmdb: TMDBConfig
    rate_limiting: RateLimitingConfig
    cache: CacheConfig
    logging: dict
    performance: dict

def validate_config(config_path: Path) -> AniVaultConfig:
    """Validate configuration file against schema."""
    with open(config_path, 'r') as f:
        config_data = toml.load(f)

    try:
        return AniVaultConfig(**config_data)
    except ValidationError as e:
        raise ConfigurationError(f"Invalid configuration: {e}")
```

## Security Scanning Implementation

### gitleaks Integration
```python
import subprocess
import json
from pathlib import Path

class SecurityScanner:
    def __init__(self, project_root: Path):
        self.project_root = project_root

    def run_gitleaks_scan(self) -> dict:
        """Run gitleaks secret detection."""
        try:
            result = subprocess.run([
                'gitleaks', 'detect',
                '--source', str(self.project_root),
                '--format', 'json',
                '--verbose'
            ], capture_output=True, text=True, check=True)

            return json.loads(result.stdout)
        except subprocess.CalledProcessError as e:
            logger.error(f"gitleaks scan failed: {e}")
            return {'secrets': []}

    def run_trufflehog_scan(self) -> dict:
        """Run trufflehog advanced secret scanning."""
        try:
            result = subprocess.run([
                'trufflehog', 'filesystem',
                '--directory', str(self.project_root),
                '--format', 'json'
            ], capture_output=True, text=True, check=True)

            return json.loads(result.stdout)
        except subprocess.CalledProcessError as e:
            logger.error(f"trufflehog scan failed: {e}")
            return {'secrets': []}
```

### pip-audit Integration
```python
def run_pip_audit() -> dict:
    """Run pip-audit vulnerability scanning."""
    try:
        result = subprocess.run([
            'pip-audit',
            '--format', 'json',
            '--output', 'vulnerabilities.json'
        ], capture_output=True, text=True, check=True)

        with open('vulnerabilities.json', 'r') as f:
            return json.load(f)
    except subprocess.CalledProcessError as e:
        logger.error(f"pip-audit scan failed: {e}")
        return {'vulnerabilities': []}
```

### SBOM Generation
```python
def generate_sbom(project_root: Path) -> dict:
    """Generate Software Bill of Materials."""
    try:
        result = subprocess.run([
            'cyclonedx-py', 'requirements',
            '--format', 'json',
            '--output', 'sbom.json'
        ], capture_output=True, text=True, check=True)

        with open('sbom.json', 'r') as f:
            return json.load(f)
    except subprocess.CalledProcessError as e:
        logger.error(f"SBOM generation failed: {e}")
        return {'components': []}
```

## Sensitive Information Handling

### Log Masking
```python
import re
from typing import Any, Dict

class SensitiveDataMasker:
    def __init__(self):
        self.patterns = [
            (r'api[_-]?key["\s]*[:=]["\s]*([^"\s]+)', r'api_key="***MASKED***"'),
            (r'tmdb[_-]?key["\s]*[:=]["\s]*([^"\s]+)', r'tmdb_key="***MASKED***"'),
            (r'password["\s]*[:=]["\s]*([^"\s]+)', r'password="***MASKED***"'),
            (r'token["\s]*[:=]["\s]*([^"\s]+)', r'token="***MASKED***"'),
        ]

    def mask_sensitive_data(self, text: str) -> str:
        """Mask sensitive data in log messages."""
        masked_text = text

        for pattern, replacement in self.patterns:
            masked_text = re.sub(pattern, replacement, masked_text, flags=re.IGNORECASE)

        return masked_text

    def mask_config_data(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Mask sensitive data in configuration objects."""
        masked_config = config.copy()

        # Mask API keys
        if 'tmdb' in masked_config:
            if 'api_key' in masked_config['tmdb']:
                masked_config['tmdb']['api_key'] = '***MASKED***'
            if 'api_key_encrypted' in masked_config['tmdb']:
                masked_config['tmdb']['api_key_encrypted'] = '***MASKED***'

        return masked_config
```

### Path Sanitization
```python
def sanitize_path(path: str) -> str:
    """Sanitize file paths for logging."""
    # Replace user home directory with ~
    home_dir = str(Path.home())
    if path.startswith(home_dir):
        return path.replace(home_dir, '~', 1)

    # Replace drive letters with *
    if len(path) > 2 and path[1] == ':':
        return '*' + path[1:]

    return path
```

## Testing Requirements
- **Encryption testing**: API key encryption/decryption
- **Configuration testing**: TOML file validation
- **Security scanning**: gitleaks, trufflehog, pip-audit
- **Masking testing**: Sensitive data masking
- **Permission testing**: File permission handling

## Risk Mitigation
- **API key exposure**: Encryption and masking
- **Configuration security**: Secure file permissions
- **Vulnerability detection**: Continuous security scanning
- **License compliance**: Third-party license tracking
- **Data leakage**: Sensitive information masking

## Timeline
**Weeks 17-18**: Security configuration implementation
**Priority**: MEDIUM - Security features and configuration management

## Dependencies
- Requires completion of Phase 1 tags (1-5) and Phase 2 tags (6-10)
- File processing pipeline established
- TMDB API integration completed
- Cache system operational
- Rate limiting implemented
- CLI commands implemented
- Organize safety features completed
- Windows compatibility implemented
- Performance optimization completed
- Testing quality implemented
