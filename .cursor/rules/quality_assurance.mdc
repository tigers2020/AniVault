---
description: Quality assurance patterns for error handling, testing, and validation
globs: src/**/*.py, tests/**/*.py, **/*test*.py
alwaysApply: true
priority: 4
---

# Quality Assurance

## 핵심 원칙

- **실패 우선 테스트**: 해피패스보다 실패 경로를 먼저 테스트하고 구현
- **예외 삼키기 금지**: 모든 예외는 적절히 처리되어야 함
- **구조적 로깅**: 에러 발생 시 맥락 정보와 함께 로깅
- **사용자 친화적 메시지**: 기술적 에러를 사용자 친화적 메시지로 변환
- **pytest 기반 테스트**: 표준화된 테스트 프레임워크 사용
- **외부 의존성 모킹**: 외부 API, 데이터베이스 등 모킹
- **비동기 테스트**: asyncio 기반 비동기 코드 테스트
- **성능 테스트**: 메모리 사용량, 실행 시간 측정

## 에러 클래스 정의

### **계층화된 에러 구조**
```python
# src/anivault/shared/errors.py
from enum import Enum
from typing import Optional, Dict, Any
from dataclasses import dataclass

class ErrorCode(str, Enum):
    """에러 코드 상수."""
    FILE_NOT_FOUND = "FILE_NOT_FOUND"
    PERMISSION_DENIED = "PERMISSION_DENIED"
    NETWORK_ERROR = "NETWORK_ERROR"
    API_RATE_LIMIT = "API_RATE_LIMIT"
    VALIDATION_ERROR = "VALIDATION_ERROR"
    PARSING_ERROR = "PARSING_ERROR"
    CACHE_ERROR = "CACHE_ERROR"
    CONFIG_ERROR = "CONFIG_ERROR"

@dataclass
class ErrorContext:
    """에러 컨텍스트 정보."""
    file_path: Optional[str] = None
    operation: Optional[str] = None
    user_id: Optional[str] = None
    additional_data: Optional[Dict[str, Any]] = None

class AniVaultError(Exception):
    """AniVault 기본 에러 클래스."""

    def __init__(
        self,
        code: ErrorCode,
        message: str,
        context: Optional[ErrorContext] = None,
        original_error: Optional[Exception] = None
    ):
        self.code = code
        self.message = message
        self.context = context
        self.original_error = original_error
        super().__init__(f"{code.value}: {message}")

class FileProcessingError(AniVaultError):
    """파일 처리 관련 에러."""
    pass

class APIError(AniVaultError):
    """API 관련 에러."""
    pass

class ValidationError(AniVaultError):
    """검증 관련 에러."""
    pass

class ConfigurationError(AniVaultError):
    """설정 관련 에러."""
    pass
```

## 구조적 에러 처리

### **견고한 에러 처리**
```python
# src/anivault/core/parser.py
import logging
from typing import Optional, Dict, Any
from pathlib import Path
from anivault.shared.errors import FileProcessingError, ErrorCode, ErrorContext

logger = logging.getLogger(__name__)

class AnimeParser:
    """애니메이션 파일 파서."""

    def parse_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """파일을 파싱합니다."""
        context = ErrorContext(
            file_path=str(file_path),
            operation="parse_file"
        )

        try:
            # 파일 존재 확인
            if not file_path.exists():
                raise FileProcessingError(
                    ErrorCode.FILE_NOT_FOUND,
                    f"파일이 존재하지 않습니다: {file_path}",
                    context
                )

            # 파일 읽기 권한 확인
            if not file_path.is_file():
                raise FileProcessingError(
                    ErrorCode.VALIDATION_ERROR,
                    f"파일이 아닙니다: {file_path}",
                    context
                )

            # 파일명 파싱
            return self._parse_filename(file_path.name)

        except FileProcessingError:
            # AniVault 에러는 그대로 재전파
            raise
        except PermissionError as e:
            logger.error(f"파일 접근 권한 없음: {file_path}", exc_info=True)
            raise FileProcessingError(
                ErrorCode.PERMISSION_DENIED,
                f"파일 접근 권한이 없습니다: {file_path}",
                context,
                original_error=e
            ) from e
        except Exception as e:
            logger.error(f"파일 파싱 중 예상치 못한 에러: {file_path}", exc_info=True)
            raise FileProcessingError(
                ErrorCode.PARSING_ERROR,
                f"파일 파싱에 실패했습니다: {file_path}",
                context,
                original_error=e
            ) from e

    def _parse_filename(self, filename: str) -> Dict[str, Any]:
        """파일명을 파싱합니다."""
        try:
            import anitopy
            result = anitopy.parse(filename)

            if not result:
                raise FileProcessingError(
                    ErrorCode.PARSING_ERROR,
                    f"파일명을 파싱할 수 없습니다: {filename}",
                    ErrorContext(operation="parse_filename")
                )

            return result

        except ImportError as e:
            logger.error("anitopy 라이브러리를 찾을 수 없습니다", exc_info=True)
            raise FileProcessingError(
                ErrorCode.CONFIG_ERROR,
                "anitopy 라이브러리가 설치되지 않았습니다",
                ErrorContext(operation="parse_filename"),
                original_error=e
            ) from e
        except Exception as e:
            logger.error(f"anitopy 파싱 에러: {filename}", exc_info=True)
            raise FileProcessingError(
                ErrorCode.PARSING_ERROR,
                f"파일명 파싱 중 에러가 발생했습니다: {filename}",
                ErrorContext(operation="parse_filename"),
                original_error=e
            ) from e
```

## API 에러 처리

### **견고한 API 에러 처리**
```python
# src/anivault/services/tmdb_client.py
import requests
import time
from typing import Dict, Any, Optional
from anivault.shared.errors import APIError, ErrorCode, ErrorContext

class TMDBClient:
    """TMDB API 클라이언트."""

    def __init__(self, api_key: str, base_url: str = "https://api.themoviedb.org/3"):
        self.api_key = api_key
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json;charset=utf-8'
        })

    def search_anime(self, query: str, max_retries: int = 3) -> Dict[str, Any]:
        """애니메이션 검색."""
        context = ErrorContext(
            operation="search_anime",
            additional_data={"query": query}
        )

        for attempt in range(max_retries):
            try:
                response = self.session.get(
                    f"{self.base_url}/search/tv",
                    params={
                        'query': query,
                        'language': 'ko-KR'
                    },
                    timeout=30
                )

                if response.status_code == 200:
                    return response.json()

                elif response.status_code == 429:  # Rate limit
                    retry_after = int(response.headers.get('Retry-After', 60))
                    logger.warning(f"API 레이트리밋 도달, {retry_after}초 대기")

                    if attempt < max_retries - 1:
                        time.sleep(retry_after)
                        continue
                    else:
                        raise APIError(
                            ErrorCode.API_RATE_LIMIT,
                            f"API 레이트리밋 초과, {retry_after}초 후 재시도하세요",
                            context
                        )

                elif response.status_code >= 500:
                    # 서버 에러 - 재시도 가능
                    if attempt < max_retries - 1:
                        wait_time = 2 ** attempt  # 지수 백오프
                        logger.warning(f"서버 에러 {response.status_code}, {wait_time}초 후 재시도")
                        time.sleep(wait_time)
                        continue
                    else:
                        raise APIError(
                            ErrorCode.NETWORK_ERROR,
                            f"서버 에러: {response.status_code}",
                            context
                        )

                else:
                    # 클라이언트 에러 - 재시도 불가
                    raise APIError(
                        ErrorCode.VALIDATION_ERROR,
                        f"API 요청 실패: {response.status_code} - {response.text}",
                        context
                    )

            except requests.exceptions.Timeout as e:
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt
                    logger.warning(f"API 타임아웃, {wait_time}초 후 재시도")
                    time.sleep(wait_time)
                    continue
                else:
                    raise APIError(
                        ErrorCode.NETWORK_ERROR,
                        "API 요청 타임아웃",
                        context,
                        original_error=e
                    ) from e

            except requests.exceptions.ConnectionError as e:
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt
                    logger.warning(f"연결 에러, {wait_time}초 후 재시도")
                    time.sleep(wait_time)
                    continue
                else:
                    raise APIError(
                        ErrorCode.NETWORK_ERROR,
                        "API 서버 연결 실패",
                        context,
                        original_error=e
                    ) from e

            except Exception as e:
                logger.error(f"API 요청 중 예상치 못한 에러: {query}", exc_info=True)
                raise APIError(
                    ErrorCode.NETWORK_ERROR,
                    f"API 요청 중 에러가 발생했습니다: {query}",
                    context,
                    original_error=e
                ) from e
```

## 사용자 친화적 에러 메시지

### **에러 메시지 변환**
```python
# src/anivault/cli/error_handler.py
from typing import Dict
from anivault.shared.errors import ErrorCode, AniVaultError

class UserFriendlyMessages:
    """사용자 친화적 에러 메시지."""

    ERROR_MESSAGES: Dict[ErrorCode, str] = {
        ErrorCode.FILE_NOT_FOUND: "파일을 찾을 수 없습니다. 파일 경로를 확인해주세요.",
        ErrorCode.PERMISSION_DENIED: "파일 접근 권한이 없습니다. 관리자 권한으로 실행하거나 파일 권한을 확인해주세요.",
        ErrorCode.NETWORK_ERROR: "네트워크 연결에 문제가 있습니다. 인터넷 연결을 확인해주세요.",
        ErrorCode.API_RATE_LIMIT: "API 요청 한도를 초과했습니다. 잠시 후 다시 시도해주세요.",
        ErrorCode.VALIDATION_ERROR: "입력 데이터에 문제가 있습니다. 데이터를 확인해주세요.",
        ErrorCode.PARSING_ERROR: "파일을 분석하는 중 문제가 발생했습니다. 파일 형식을 확인해주세요.",
        ErrorCode.CACHE_ERROR: "캐시 처리 중 문제가 발생했습니다. 캐시를 삭제하고 다시 시도해주세요.",
        ErrorCode.CONFIG_ERROR: "설정 파일에 문제가 있습니다. 설정을 확인해주세요."
    }

    @classmethod
    def get_message(cls, error: AniVaultError) -> str:
        """에러에 대한 사용자 친화적 메시지 반환."""
        base_message = cls.ERROR_MESSAGES.get(error.code, "예상치 못한 오류가 발생했습니다.")

        # 컨텍스트 정보 추가
        if error.context and error.context.file_path:
            base_message += f"\n파일: {error.context.file_path}"

        if error.context and error.context.operation:
            base_message += f"\n작업: {error.context.operation}"

        return base_message

def handle_error(error: Exception) -> str:
    """에러를 사용자 친화적 메시지로 변환."""
    if isinstance(error, AniVaultError):
        return UserFriendlyMessages.get_message(error)
    else:
        return f"예상치 못한 오류가 발생했습니다: {str(error)}"
```

## 테스트 패턴

### **기본 테스트 클래스 구조**
```python
# tests/core/test_parser.py
import pytest
from unittest.mock import Mock, patch
from pathlib import Path
from anivault.core.parser import AnimeParser
from anivault.shared.errors import FileProcessingError, ErrorCode

class TestAnimeParser:
    """애니메이션 파서 테스트."""

    def setup_method(self) -> None:
        """각 테스트 메서드 실행 전 설정."""
        self.parser = AnimeParser()
        self.test_file = Path("test_anime.mkv")

    def teardown_method(self) -> None:
        """각 테스트 메서드 실행 후 정리."""
        if self.test_file.exists():
            self.test_file.unlink()

    def test_parse_file_success(self) -> None:
        """파일 파싱 성공 테스트."""
        # Given
        self.test_file.write_text("test content")

        # When
        result = self.parser.parse_file(self.test_file)

        # Then
        assert result is not None
        assert isinstance(result, dict)

    def test_parse_file_not_found(self) -> None:
        """파일이 존재하지 않을 때 에러 테스트."""
        # Given
        non_existent_file = Path("non_existent.mkv")

        # When & Then
        with pytest.raises(FileProcessingError) as exc_info:
            self.parser.parse_file(non_existent_file)

        assert exc_info.value.code == ErrorCode.FILE_NOT_FOUND
        assert "파일이 존재하지 않습니다" in exc_info.value.message
```

### **픽스처 활용**
```python
# tests/conftest.py
import pytest
from pathlib import Path
from tempfile import TemporaryDirectory
from anivault.core.parser import AnimeParser

@pytest.fixture
def sample_anime_file() -> Path:
    """샘플 애니메이션 파일 픽스처."""
    with TemporaryDirectory() as temp_dir:
        file_path = Path(temp_dir) / "Attack on Titan S01E01.mkv"
        file_path.write_text("test content")
        yield file_path

@pytest.fixture
def anime_parser() -> AnimeParser:
    """애니메이션 파서 픽스처."""
    return AnimeParser()

@pytest.fixture
def mock_tmdb_response() -> dict:
    """TMDB API 응답 모킹 픽스처."""
    return {
        "results": [
            {
                "id": 12345,
                "name": "Attack on Titan",
                "first_air_date": "2013-04-07",
                "overview": "Humanity fights for survival..."
            }
        ]
    }
```

### **외부 API 모킹**
```python
# tests/services/test_tmdb_client.py
import pytest
from unittest.mock import Mock, patch
from anivault.services.tmdb_client import TMDBClient
from anivault.shared.errors import APIError, ErrorCode

class TestTMDBClient:
    """TMDB 클라이언트 테스트."""

    def setup_method(self) -> None:
        """테스트 설정."""
        self.client = TMDBClient("test_api_key")

    @patch('anivault.services.tmdb_client.requests.Session.get')
    def test_search_anime_success(self, mock_get: Mock) -> None:
        """애니메이션 검색 성공 테스트."""
        # Given
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"results": []}
        mock_get.return_value = mock_response

        # When
        result = self.client.search_anime("Attack on Titan")

        # Then
        assert result == {"results": []}
        mock_get.assert_called_once()

    @patch('anivault.services.tmdb_client.requests.Session.get')
    def test_search_anime_rate_limit(self, mock_get: Mock) -> None:
        """API 레이트리밋 에러 테스트."""
        # Given
        mock_response = Mock()
        mock_response.status_code = 429
        mock_response.headers = {'Retry-After': '60'}
        mock_get.return_value = mock_response

        # When & Then
        with pytest.raises(APIError) as exc_info:
            self.client.search_anime("Attack on Titan", max_retries=1)

        assert exc_info.value.code == ErrorCode.API_RATE_LIMIT
        assert "API 레이트리밋 초과" in exc_info.value.message
```

### **비동기 함수 테스트**
```python
# tests/core/test_async_processor.py
import pytest
import asyncio
from pathlib import Path
from anivault.core.async_processor import AsyncAnimeProcessor

class TestAsyncAnimeProcessor:
    """비동기 애니메이션 프로세서 테스트."""

    @pytest.mark.asyncio
    async def test_process_files_async(self) -> None:
        """비동기 파일 처리 테스트."""
        # Given
        processor = AsyncAnimeProcessor()
        test_files = [
            Path("test1.mkv"),
            Path("test2.mp4")
        ]

        # 테스트 파일 생성
        for file_path in test_files:
            file_path.write_text("test content")

        try:
            # When
            results = await processor.process_files_async(test_files)

            # Then
            assert len(results) == 2
            assert all(result['success'] for result in results)

        finally:
            # 정리
            for file_path in test_files:
                if file_path.exists():
                    file_path.unlink()
```

### **파라미터화된 테스트**
```python
# tests/core/test_file_validation.py
import pytest
from pathlib import Path
from anivault.core.validator import FileValidator

class TestFileValidator:
    """파일 검증기 테스트."""

    @pytest.mark.parametrize("file_extension,expected", [
        (".mkv", True),
        (".mp4", True),
        (".avi", True),
        (".txt", False),
        (".doc", False),
        (".", False),
        ("", False)
    ])
    def test_is_supported_extension(self, file_extension: str, expected: bool) -> None:
        """지원되는 확장자 테스트."""
        # Given
        validator = FileValidator()

        # When
        result = validator.is_supported_extension(file_extension)

        # Then
        assert result == expected

    @pytest.mark.parametrize("file_size,expected", [
        (1024, True),  # 1KB
        (1024 * 1024, True),  # 1MB
        (1024 * 1024 * 1024, True),  # 1GB
        (1024 * 1024 * 1024 * 2, False),  # 2GB (제한 초과)
    ])
    def test_is_valid_file_size(self, file_size: int, expected: bool) -> None:
        """파일 크기 검증 테스트."""
        # Given
        validator = FileValidator()

        # When
        result = validator.is_valid_file_size(file_size)

        # Then
        assert result == expected
```

### **통합 테스트**
```python
# tests/integration/test_full_pipeline.py
import pytest
from pathlib import Path
from tempfile import TemporaryDirectory
from anivault.core.pipeline import AnimeProcessingPipeline

class TestAnimeProcessingPipeline:
    """애니메이션 처리 파이프라인 통합 테스트."""

    def test_full_pipeline_integration(self) -> None:
        """전체 파이프라인 통합 테스트."""
        with TemporaryDirectory() as temp_dir:
            # Given
            input_dir = Path(temp_dir) / "input"
            output_dir = Path(temp_dir) / "output"
            input_dir.mkdir()
            output_dir.mkdir()

            # 테스트 파일 생성
            test_file = input_dir / "Attack on Titan S01E01.mkv"
            test_file.write_text("test content")

            pipeline = AnimeProcessingPipeline(
                input_dir=input_dir,
                output_dir=output_dir
            )

            # When
            results = pipeline.process_all()

            # Then
            assert len(results) == 1
            assert results[0]['success'] is True
            assert results[0]['file_name'] == "Attack on Titan S01E01.mkv"
```

### **성능 테스트**
```python
# tests/performance/test_memory_usage.py
import pytest
import psutil
import os
from pathlib import Path
from anivault.core.processor import AnimeProcessor

class TestMemoryUsage:
    """메모리 사용량 테스트."""

    def test_memory_usage_with_large_files(self) -> None:
        """대용량 파일 처리 시 메모리 사용량 테스트."""
        # Given
        processor = AnimeProcessor()
        large_files = [Path(f"large_file_{i}.mkv") for i in range(100)]

        # 대용량 파일 생성 (각 10MB)
        for file_path in large_files:
            file_path.write_bytes(b"0" * (10 * 1024 * 1024))

        try:
            # When
            process = psutil.Process(os.getpid())
            memory_before = process.memory_info().rss

            results = processor.process_files(large_files)

            memory_after = process.memory_info().rss
            memory_used = memory_after - memory_before

            # Then
            assert len(results) == 100
            assert memory_used < 100 * 1024 * 1024  # 100MB 미만 사용
            assert memory_used / (100 * 1024 * 1024) < 0.1  # 10% 미만 사용률

        finally:
            # 정리
            for file_path in large_files:
                if file_path.exists():
                    file_path.unlink()
```

## 안티패턴 및 금지사항

### **❌ DON'T: 예외 삼키기**
```python
# ❌ BAD: 예외를 무시하거나 삼키기
def bad_parse_file(file_path: Path) -> Optional[Dict]:
    try:
        return anitopy.parse(file_path.name)
    except Exception:
        pass  # ❌ 에러 정보 완전 손실
        return None

def bad_parse_file_2(file_path: Path) -> Optional[Dict]:
    try:
        return anitopy.parse(file_path.name)
    except Exception as e:
        print(f"Error: {e}")  # ❌ 로깅 없음, 재전파 없음
        return None  # ❌ 에러 정보 손실
```

### **❌ DON'T: 잘못된 테스트 패턴**
```python
# ❌ BAD: 테스트에서 print 사용
def test_something():
    result = some_function()
    print(f"Result: {result}")  # ❌ assert 사용해야 함
    assert result is not None

# ❌ BAD: 외부 의존성 모킹하지 않음
def test_api_call():
    client = TMDBClient("real_api_key")  # ❌ 실제 API 호출
    result = client.search_anime("Attack on Titan")
    assert result is not None

# ❌ BAD: 테스트 데이터 정리하지 않음
def test_file_processing():
    test_file = Path("test.mkv")
    test_file.write_text("content")
    # ❌ 파일 정리 없음
    result = process_file(test_file)
    assert result is not None
```

### **✅ DO: 올바른 패턴**
```python
# ✅ DO: 적절한 예외 처리
def good_parse_file(file_path: Path) -> Dict[str, Any]:
    try:
        result = anitopy.parse(file_path.name)
        if not result:
            raise FileProcessingError(
                ErrorCode.PARSING_ERROR,
                f"파일명을 파싱할 수 없습니다: {file_path.name}"
            )
        return result
    except Exception as e:
        logger.error(f"파일 파싱 에러: {file_path}", exc_info=True)
        raise FileProcessingError(
            ErrorCode.PARSING_ERROR,
            f"파일 파싱에 실패했습니다: {file_path}",
            original_error=e
        ) from e

# ✅ DO: 적절한 테스트
def test_something():
    result = some_function()
    assert result is not None
    assert isinstance(result, dict)

# ✅ DO: 외부 의존성 모킹
@patch('anivault.services.tmdb_client.requests.Session.get')
def test_api_call(mock_get):
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"results": []}
    mock_get.return_value = mock_response

    client = TMDBClient("test_key")
    result = client.search_anime("Attack on Titan")
    assert result == {"results": []}

# ✅ DO: 테스트 데이터 정리
def test_file_processing():
    test_file = Path("test.mkv")
    try:
        test_file.write_text("content")
        result = process_file(test_file)
        assert result is not None
    finally:
        if test_file.exists():
            test_file.unlink()
```

## 관련 규칙

- **Python 개발**: [python_development.mdc](mdc:.cursor/rules/python_development.mdc)
- **시스템 표준**: [system_standards.mdc](mdc:.cursor/rules/system_standards.mdc)
- **파일 처리**: [file_processing.mdc](mdc:.cursor/rules/file_processing.mdc)
- **TMDB API**: [tmdb_api.mdc](mdc:.cursor/rules/tmdb_api.mdc)
