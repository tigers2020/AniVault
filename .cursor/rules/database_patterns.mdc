---
description: SQLAlchemy ORM and database patterns guide
globs: src/core/database.py, src/core/*db*.py, **/*database*.py, **/*model*.py
alwaysApply: false
---

# 데이터베이스 패턴 가이드

## 핵심 원칙

- **트랜잭션 안전성**: 모든 데이터베이스 작업을 트랜잭션으로 보호
- **연결 관리**: 세션 생명주기를 명확히 관리
- **에러 복구**: 데이터베이스 에러에 대한 적절한 처리
- **성능 최적화**: 벌크 작업과 인덱스 활용

## SQLAlchemy 모델 설계

### **기본 모델 구조**
```python
# ✅ DO: 표준 SQLAlchemy 모델
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, Index
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class AnimeMetadata(Base):
    """애니메이션 메타데이터 모델."""

    __tablename__ = "anime_metadata"

    # Primary key
    tmdb_id = Column(Integer, primary_key=True, nullable=False)

    # Basic information
    title = Column(String(255), nullable=False, index=True)
    original_title = Column(String(255), nullable=True, index=True)
    overview = Column(Text, nullable=True)

    # Timestamps
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Versioning for conflict resolution
    version = Column(Integer, nullable=False, default=1, index=True)

    # Relationships
    parsed_files = relationship("ParsedFile", back_populates="metadata")

    # Indexes
    __table_args__ = (
        Index("idx_anime_metadata_title", "title"),
        Index("idx_anime_metadata_created_at", "created_at"),
    )
```

### **관계 설정**
```python
# ✅ DO: 명확한 관계 설정
class ParsedFile(Base):
    """파싱된 파일 정보 모델."""

    __tablename__ = "parsed_files"

    id = Column(Integer, primary_key=True, autoincrement=True)
    file_path = Column(String(500), nullable=False, unique=True, index=True)
    metadata_id = Column(Integer, ForeignKey("anime_metadata.tmdb_id"), nullable=True)

    # Relationships
    metadata = relationship("AnimeMetadata", back_populates="parsed_files")

    # Indexes
    __table_args__ = (
        Index("idx_parsed_files_path", "file_path"),
        Index("idx_parsed_files_metadata_id", "metadata_id"),
    )
```

## 세션 관리

### **컨텍스트 매니저 패턴**
```python
# ✅ DO: 안전한 세션 관리
from contextlib import contextmanager
from sqlalchemy.orm import Session, sessionmaker

class DatabaseManager:
    """데이터베이스 관리자."""

    def __init__(self, database_url: str):
        self.engine = create_engine(database_url)
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)

    @contextmanager
    def get_session(self) -> Generator[Session, None, None]:
        """데이터베이스 세션 컨텍스트 매니저."""
        session = self.SessionLocal()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

    def get_session_sync(self) -> Session:
        """동기 세션 반환."""
        return self.SessionLocal()
```

### **트랜잭션 관리**
```python
# ✅ DO: 트랜잭션 매니저 사용
class TransactionManager:
    """트랜잭션 관리자."""

    def __init__(self, timeout_seconds: int = 300):
        self.timeout_seconds = timeout_seconds
        self._active_transactions: Dict[str, Session] = {}

    @contextmanager
    def transaction(self, operation_name: str) -> Generator[Session, None, None]:
        """트랜잭션 컨텍스트 매니저."""
        session = self.SessionLocal()
        transaction_id = f"{operation_name}_{datetime.now().timestamp()}"

        try:
            self._active_transactions[transaction_id] = session
            yield session
            session.commit()
            logger.info(f"Transaction {operation_name} committed successfully")
        except Exception as e:
            session.rollback()
            logger.error(f"Transaction {operation_name} rolled back: {e}")
            raise
        finally:
            self._active_transactions.pop(transaction_id, None)
            session.close()
```

## CRUD 작업 패턴

### **기본 CRUD 작업**
```python
# ✅ DO: 표준 CRUD 작업
class AnimeMetadataRepository:
    """애니메이션 메타데이터 저장소."""

    def __init__(self, session: Session):
        self.session = session

    def create(self, metadata: AnimeMetadata) -> AnimeMetadata:
        """메타데이터 생성."""
        try:
            self.session.add(metadata)
            self.session.flush()  # ID 생성
            return metadata
        except Exception as e:
            log_database_error("create anime metadata", e, "anime_metadata")
            raise

    def get_by_id(self, tmdb_id: int) -> AnimeMetadata | None:
        """ID로 메타데이터 조회."""
        try:
            return self.session.query(AnimeMetadata).filter(
                AnimeMetadata.tmdb_id == tmdb_id
            ).first()
        except Exception as e:
            log_database_error("get anime metadata by id", e, "anime_metadata")
            return None

    def update(self, metadata: AnimeMetadata) -> AnimeMetadata:
        """메타데이터 업데이트."""
        try:
            metadata.updated_at = datetime.utcnow()
            metadata.version += 1
            self.session.merge(metadata)
            return metadata
        except Exception as e:
            log_database_error("update anime metadata", e, "anime_metadata")
            raise

    def delete(self, tmdb_id: int) -> bool:
        """메타데이터 삭제."""
        try:
            metadata = self.get_by_id(tmdb_id)
            if metadata:
                self.session.delete(metadata)
                return True
            return False
        except Exception as e:
            log_database_error("delete anime metadata", e, "anime_metadata")
            raise
```

### **벌크 작업**
```python
# ✅ DO: 효율적인 벌크 작업
def bulk_insert_anime_metadata(
    session: Session,
    metadata_list: list[AnimeMetadata]
) -> int:
    """벌크 메타데이터 삽입."""
    try:
        session.bulk_insert_mappings(AnimeMetadata, [
            {
                "tmdb_id": m.tmdb_id,
                "title": m.title,
                "original_title": m.original_title,
                "overview": m.overview,
                "created_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
                "version": 1
            }
            for m in metadata_list
        ])
        session.commit()
        return len(metadata_list)
    except Exception as e:
        log_database_error("bulk insert anime metadata", e, "anime_metadata")
        session.rollback()
        raise

def bulk_upsert_anime_metadata(
    session: Session,
    metadata_list: list[AnimeMetadata]
) -> int:
    """벌크 업서트 (삽입 또는 업데이트)."""
    try:
        # 기존 데이터 조회
        tmdb_ids = [m.tmdb_id for m in metadata_list]
        existing = session.query(AnimeMetadata).filter(
            AnimeMetadata.tmdb_id.in_(tmdb_ids)
        ).all()
        existing_ids = {m.tmdb_id for m in existing}

        # 새 데이터와 업데이트 데이터 분리
        new_items = [m for m in metadata_list if m.tmdb_id not in existing_ids]
        update_items = [m for m in metadata_list if m.tmdb_id in existing_ids]

        # 새 데이터 삽입
        if new_items:
            bulk_insert_anime_metadata(session, new_items)

        # 기존 데이터 업데이트
        for item in update_items:
            session.merge(item)

        session.commit()
        return len(metadata_list)
    except Exception as e:
        log_database_error("bulk upsert anime metadata", e, "anime_metadata")
        session.rollback()
        raise
```

## 쿼리 최적화

### **인덱스 활용**
```python
# ✅ DO: 인덱스를 활용한 효율적인 쿼리
def search_anime_by_title(session: Session, title: str) -> list[AnimeMetadata]:
    """제목으로 애니메이션 검색 (인덱스 활용)."""
    return session.query(AnimeMetadata).filter(
        AnimeMetadata.title.ilike(f"%{title}%")
    ).all()

def get_anime_by_date_range(
    session: Session,
    start_date: datetime,
    end_date: datetime
) -> list[AnimeMetadata]:
    """날짜 범위로 애니메이션 조회 (인덱스 활용)."""
    return session.query(AnimeMetadata).filter(
        AnimeMetadata.first_air_date.between(start_date, end_date)
    ).all()
```

### **N+1 문제 해결**
```python
# ✅ DO: N+1 문제 방지
def get_anime_with_files(session: Session, tmdb_id: int) -> AnimeMetadata | None:
    """파일 정보와 함께 애니메이션 조회 (eager loading)."""
    return session.query(AnimeMetadata).options(
        joinedload(AnimeMetadata.parsed_files)
    ).filter(AnimeMetadata.tmdb_id == tmdb_id).first()

def get_all_anime_with_files(session: Session) -> list[AnimeMetadata]:
    """모든 애니메이션과 파일 정보 조회 (eager loading)."""
    return session.query(AnimeMetadata).options(
        joinedload(AnimeMetadata.parsed_files)
    ).all()
```

## 재시도 로직

### **데이터베이스 재시도**
```python
# ✅ DO: 데이터베이스 작업 재시도
from tenacity import retry, stop_after_attempt, wait_exponential
from sqlalchemy.exc import OperationalError, DisconnectionError

@retry(
    retry=retry_if_exception_type((OperationalError, DisconnectionError)),
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10)
)
def robust_database_operation(operation: Callable[[], T]) -> T:
    """견고한 데이터베이스 작업."""
    return operation()

def get_anime_with_retry(session: Session, tmdb_id: int) -> AnimeMetadata | None:
    """재시도 로직이 포함된 조회."""
    def _get_anime():
        return session.query(AnimeMetadata).filter(
            AnimeMetadata.tmdb_id == tmdb_id
        ).first()

    return robust_database_operation(_get_anime)
```

## 스키마 관리

### **마이그레이션 관리**
```python
# ✅ DO: Alembic 마이그레이션 사용
from alembic import command
from alembic.config import Config

def run_migrations():
    """데이터베이스 마이그레이션 실행."""
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")

def create_migration(message: str):
    """새 마이그레이션 생성."""
    alembic_cfg = Config("alembic.ini")
    command.revision(alembic_cfg, message=message, autogenerate=True)
```

### **스키마 검증**
```python
# ✅ DO: 스키마 검증
def validate_schema(session: Session) -> bool:
    """데이터베이스 스키마 검증."""
    try:
        # 필수 테이블 존재 확인
        required_tables = ["anime_metadata", "parsed_files"]
        inspector = inspect(session.bind)
        existing_tables = inspector.get_table_names()

        missing_tables = set(required_tables) - set(existing_tables)
        if missing_tables:
            logger.error(f"Missing tables: {missing_tables}")
            return False

        # 테이블 구조 검증
        for table_name in required_tables:
            if not validate_table_structure(session, table_name):
                return False

        return True
    except Exception as e:
        log_schema_error("schema validation", e)
        return False
```

## 안티패턴 및 금지사항

### **❌ DON'T: 잘못된 데이터베이스 패턴**
```python
# ❌ DON'T: 세션 관리 없이 사용
def bad_database_usage():
    session = SessionLocal()  # ❌ 세션 관리 없음
    result = session.query(AnimeMetadata).all()
    return result  # ❌ 세션 닫지 않음

# ❌ DON'T: 트랜잭션 없이 여러 작업
def bad_multiple_operations():
    session = SessionLocal()
    session.add(metadata1)  # ❌ 트랜잭션 없음
    session.add(metadata2)  # ❌ 중간에 실패하면 일관성 깨짐
    session.commit()

# ❌ DON'T: N+1 쿼리 문제
def bad_n_plus_one():
    animes = session.query(AnimeMetadata).all()  # ❌
    for anime in animes:
        files = session.query(ParsedFile).filter(
            ParsedFile.metadata_id == anime.tmdb_id
        ).all()  # ❌ 각 애니메이션마다 별도 쿼리
```

### **✅ DO: 올바른 데이터베이스 패턴**
```python
# ✅ DO: 안전한 세션 관리
def good_database_usage():
    with get_session() as session:
        return session.query(AnimeMetadata).all()

# ✅ DO: 트랜잭션으로 보호된 작업
def good_transactional_operations():
    with transaction("bulk_operations") as session:
        session.add(metadata1)
        session.add(metadata2)
        # 트랜잭션으로 보호됨

# ✅ DO: N+1 문제 해결
def good_eager_loading():
    return session.query(AnimeMetadata).options(
        joinedload(AnimeMetadata.parsed_files)
    ).all()
```

## 테스트 패턴

### **데이터베이스 테스트**
```python
# ✅ DO: 데이터베이스 테스트
@pytest.fixture
def db_session():
    """테스트용 데이터베이스 세션."""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    SessionLocal = sessionmaker(bind=engine)
    session = SessionLocal()
    yield session
    session.close()

def test_create_anime_metadata(db_session):
    """애니메이션 메타데이터 생성 테스트."""
    metadata = AnimeMetadata(
        tmdb_id=12345,
        title="Test Anime",
        original_title="テストアニメ"
    )

    db_session.add(metadata)
    db_session.commit()

    result = db_session.query(AnimeMetadata).filter(
        AnimeMetadata.tmdb_id == 12345
    ).first()

    assert result is not None
    assert result.title == "Test Anime"
```

## 관련 룰 참조

- **에러 처리**: [error_handling.mdc](mdc:.cursor/rules/error_handling.mdc)
- **로깅**: [logging.mdc](mdc:.cursor/rules/logging.mdc)
- **성능**: [performance.mdc](mdc:.cursor/rules/performance.mdc)
