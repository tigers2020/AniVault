---
description: Guidelines and patterns for AI agent and automation system development
globs: src/core/*agent*.py, src/core/*automation*.py, src/core/*orchestrator*.py, src/core/*manager*.py
alwaysApply: false
---

# AI 에이전트 및 자동화 시스템 개발 가이드

## 핵심 원칙

- **단일 책임 원칙**: 각 에이전트는 명확한 하나의 목적만 담당
- **비동기 우선**: 모든 외부 API 호출과 파일 I/O는 비동기로 처리
- **상태 관리**: 명확한 상태 전환과 오류 복구 메커니즘 구현
- **모니터링**: 모든 에이전트 활동에 대한 로깅과 메트릭 수집

## 에이전트 아키텍처 패턴

### **에이전트 기본 구조**
```python
# ✅ DO: 표준 에이전트 클래스 구조
from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, Dict, Any
import asyncio
from PyQt5.QtCore import QObject, pyqtSignal

class AgentState(Enum):
    IDLE = "idle"
    RUNNING = "running"
    ERROR = "error"
    COMPLETED = "completed"

class BaseAgent(QObject, ABC):
    """모든 에이전트의 기본 클래스."""
    
    # 상태 변경 시그널
    state_changed = pyqtSignal(AgentState)
    progress_updated = pyqtSignal(int)  # 0-100
    result_ready = pyqtSignal(dict)
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__()
        self.config = config
        self._state = AgentState.IDLE
        self._result: Optional[Dict[str, Any]] = None
        self._error: Optional[Exception] = None
        
    @property
    def state(self) -> AgentState:
        return self._state
        
    @state.setter
    def state(self, new_state: AgentState) -> None:
        if self._state != new_state:
            self._state = new_state
            self.state_changed.emit(new_state)
            
    @abstractmethod
    async def execute(self) -> Dict[str, Any]:
        """에이전트의 주요 작업을 실행합니다."""
        pass
        
    async def run(self) -> Dict[str, Any]:
        """에이전트 실행 래퍼 (오류 처리 포함)."""
        try:
            self.state = AgentState.RUNNING
            self._result = await self.execute()
            self.state = AgentState.COMPLETED
            self.result_ready.emit(self._result)
            return self._result
        except Exception as e:
            self._error = e
            self.state = AgentState.ERROR
            raise
```

### **에이전트 매니저 패턴**
```python
# ✅ DO: 에이전트 생명주기 관리
class AgentManager(QObject):
    """여러 에이전트를 관리하는 매니저 클래스."""
    
    def __init__(self):
        super().__init__()
        self._agents: Dict[str, BaseAgent] = {}
        self._running_tasks: Dict[str, asyncio.Task] = {}
        
    def register_agent(self, name: str, agent: BaseAgent) -> None:
        """에이전트를 등록합니다."""
        self._agents[name] = agent
        agent.state_changed.connect(
            lambda state: self._on_agent_state_changed(name, state)
        )
        
    async def run_agent(self, name: str) -> Dict[str, Any]:
        """에이전트를 실행합니다."""
        if name not in self._agents:
            raise ValueError(f"Agent '{name}' not registered")
            
        if name in self._running_tasks:
            raise RuntimeError(f"Agent '{name}' is already running")
            
        agent = self._agents[name]
        task = asyncio.create_task(agent.run())
        self._running_tasks[name] = task
        
        try:
            return await task
        finally:
            self._running_tasks.pop(name, None)
            
    async def run_agents_parallel(self, agent_names: List[str]) -> Dict[str, Any]:
        """여러 에이전트를 병렬로 실행합니다."""
        tasks = []
        for name in agent_names:
            if name in self._agents:
                tasks.append(self.run_agent(name))
                
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return dict(zip(agent_names, results))
```

## 특화된 에이전트 패턴

### **TMDB 검색 에이전트**
```python
# ✅ DO: TMDB API 전용 에이전트
class TMDBSearchAgent(BaseAgent):
    """TMDB API를 통한 애니메이션 검색 에이전트."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.tmdb_client = create_tmdb_client(TMDBConfig(api_key=config['api_key']))
        self.search_strategies = config.get('strategies', ['original', 'normalized'])
        
    async def execute(self) -> Dict[str, Any]:
        """TMDB 검색을 실행합니다."""
        query = self.config['query']
        results = []
        
        for strategy in self.search_strategies:
            try:
                self.progress_updated.emit(20)
                search_results = await self.tmdb_client.search_comprehensive(
                    query, 
                    strategy=SearchStrategyType(strategy)
                )
                results.extend(search_results)
                
                if results:  # 결과가 있으면 조기 종료
                    break
                    
            except Exception as e:
                logger.warning(f"Search strategy {strategy} failed: {e}")
                continue
                
        self.progress_updated.emit(100)
        return {
            'query': query,
            'results': results,
            'total_found': len(results)
        }
```

### **파일 처리 에이전트**
```python
# ✅ DO: 파일 처리 전용 에이전트
class FileProcessingAgent(BaseAgent):
    """애니메이션 파일 처리 에이전트."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.file_paths = config['file_paths']
        self.batch_size = config.get('batch_size', 10)
        
    async def execute(self) -> Dict[str, Any]:
        """파일 처리를 실행합니다."""
        processed_files = []
        total_files = len(self.file_paths)
        
        for i in range(0, total_files, self.batch_size):
            batch = self.file_paths[i:i + self.batch_size]
            
            # 배치 처리
            batch_results = await self._process_batch(batch)
            processed_files.extend(batch_results)
            
            # 진행률 업데이트
            progress = int((i + len(batch)) / total_files * 100)
            self.progress_updated.emit(progress)
            
        return {
            'processed_files': processed_files,
            'total_processed': len(processed_files),
            'success_rate': len([f for f in processed_files if f['success']]) / len(processed_files)
        }
        
    async def _process_batch(self, batch: List[str]) -> List[Dict[str, Any]]:
        """파일 배치를 처리합니다."""
        tasks = [self._process_single_file(path) for path in batch]
        return await asyncio.gather(*tasks, return_exceptions=True)
```

## 오케스트레이션 패턴

### **워크플로우 오케스트레이터**
```python
# ✅ DO: 복합 작업 오케스트레이션
class WorkflowOrchestrator(QObject):
    """여러 에이전트를 조합한 워크플로우를 관리합니다."""
    
    def __init__(self):
        super().__init__()
        self.agent_manager = AgentManager()
        self.workflows: Dict[str, List[str]] = {}
        
    def define_workflow(self, name: str, agent_sequence: List[str]) -> None:
        """워크플로우를 정의합니다."""
        self.workflows[name] = agent_sequence
        
    async def execute_workflow(self, name: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """워크플로우를 실행합니다."""
        if name not in self.workflows:
            raise ValueError(f"Workflow '{name}' not defined")
            
        workflow_steps = self.workflows[name]
        results = {}
        
        for step in workflow_steps:
            # 각 단계별 설정 병합
            step_config = {**config, **config.get(f'{step}_config', {})}
            self.agent_manager._agents[step].config = step_config
            
            # 에이전트 실행
            step_result = await self.agent_manager.run_agent(step)
            results[step] = step_result
            
            # 다음 단계로 결과 전달
            config[f'{step}_result'] = step_result
            
        return results
```

## 모니터링 및 로깅

### **에이전트 메트릭 수집**
```python
# ✅ DO: 에이전트 성능 모니터링
class AgentMetrics:
    """에이전트 성능 메트릭을 수집합니다."""
    
    def __init__(self):
        self.execution_times: Dict[str, List[float]] = defaultdict(list)
        self.error_counts: Dict[str, int] = defaultdict(int)
        self.success_rates: Dict[str, float] = {}
        
    def record_execution(self, agent_name: str, execution_time: float, success: bool) -> None:
        """에이전트 실행 결과를 기록합니다."""
        self.execution_times[agent_name].append(execution_time)
        
        if not success:
            self.error_counts[agent_name] += 1
            
        # 성공률 계산
        total_executions = len(self.execution_times[agent_name])
        successful_executions = total_executions - self.error_counts[agent_name]
        self.success_rates[agent_name] = successful_executions / total_executions
        
    def get_metrics(self) -> Dict[str, Any]:
        """수집된 메트릭을 반환합니다."""
        return {
            'execution_times': dict(self.execution_times),
            'error_counts': dict(self.error_counts),
            'success_rates': self.success_rates
        }
```

## 안티패턴 및 금지사항

### **❌ DON'T: 잘못된 에이전트 설계**
```python
# ❌ DON'T: 동기식 API 호출
class BadTMDBAgent:
    def search(self, query: str):
        # 동기식 호출 - GUI 블로킹
        response = requests.get(f"https://api.themoviedb.org/3/search/tv?query={query}")
        return response.json()

# ❌ DON'T: 상태 관리 없는 에이전트
class BadFileAgent:
    def process_files(self, files):
        # 상태 정보 없음 - 진행 상황 추적 불가
        for file in files:
            # 처리 로직
            pass

# ❌ DON'T: 오류 처리 없는 에이전트
class BadProcessingAgent:
    def execute(self):
        # 오류 처리 없음 - 시스템 불안정
        result = risky_operation()
        return result
```

## 에이전트 통합 가이드라인

### **기존 시스템과의 통합**
- **GUI 통합**: PyQt5 시그널/슬롯을 통한 비동기 통신
- **데이터베이스 통합**: SQLAlchemy 세션을 안전하게 관리
- **설정 관리**: ConfigManager와 연동된 설정 시스템
- **로깅 통합**: 기존 로깅 시스템과 일관된 로그 레벨 사용

### **성능 최적화**
- **연결 풀링**: HTTP 클라이언트와 데이터베이스 연결 재사용
- **배치 처리**: 대량 데이터 처리 시 청크 단위로 분할
- **캐싱**: 반복적인 작업 결과 캐싱
- **병렬 처리**: 독립적인 작업들의 병렬 실행

### **테스트 전략**
- **단위 테스트**: 각 에이전트의 독립적 테스트
- **통합 테스트**: 에이전트 간 상호작용 테스트
- **성능 테스트**: 대용량 데이터 처리 성능 검증
- **모킹**: 외부 API 호출 및 파일 I/O 모킹

## 관련 룰 참조

- **비동기 처리**: [async_patterns.mdc](mdc:.cursor/rules/async_patterns.mdc)
- **에러 처리**: [error_handling.mdc](mdc:.cursor/rules/error_handling.mdc)
- **로깅**: [logging.mdc](mdc:.cursor/rules/logging.mdc)
- **테스트**: [testing.mdc](mdc:.cursor/rules/testing.mdc)
- **성능**: [performance.mdc](mdc:.cursor/rules/performance.mdc)
- **데이터베이스**: [database_patterns.mdc](mdc:.cursor/rules/database_patterns.mdc)