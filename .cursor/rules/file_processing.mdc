---
description: File scanning, parsing, and grouping patterns guide
globs: src/core/file_scanner.py, src/core/file_parser.py, src/core/file_grouper.py, **/*file*.py
alwaysApply: false
priority: 7
---

# File Processing and Parsing Patterns Guide

## Core Principles

- **UTF-8 Enforcement**: All file I/O MUST use UTF-8 encoding
- **Extension Whitelist**: Process only animation-related extensions
- **Recursive Scan**: Scan all files including subdirectories
- **Parsing Accuracy**: Target parsing failure rate ≤ 3%
- **Grouping Algorithm**: rapidfuzz-based similarity matching
- **Duplicate Removal**: Version-based duplicate file handling rules

## 파일 스캔 패턴

### **기본 파일 스캐너**
```python
# ✅ DO: AniVault 파일 스캐너 (UTF-8 전제)
import os
from pathlib import Path
from typing import List, Generator, Callable, Optional
from concurrent.futures import ThreadPoolExecutor
import logging

# AniVault 지원 확장자 (개발 계획서 기준)
SUPPORTED_EXTENSIONS = {
    '.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm',  # 비디오
    '.srt', '.ass', '.ssa', '.vtt',  # 자막
    '.m4a', '.aac', '.flac', '.mp3', '.wav',  # 오디오
}

class AniVaultFileScanner:
    """AniVault 파일 스캐너 - UTF-8 전제, 확장자 화이트리스트."""

    def __init__(self,
                 max_workers: int = 4,
                 progress_callback: Optional[Callable[[int, int], None]] = None):
        self.max_workers = max_workers
        self.progress_callback = progress_callback
        self.logger = logging.getLogger("pipeline.scanner")

    def scan_directory(self, directory: Path, recursive: bool = True) -> List[Path]:
        """디렉토리 스캔 - UTF-8 환경에서 실행."""
        if not directory.exists():
            raise FileNotFoundError(f"Directory not found: {directory}")

        if not directory.is_dir():
            raise NotADirectoryError(f"Not a directory: {directory}")

        self.logger.info(f"Starting directory scan: {directory}")

        files = []
        if recursive:
            files = list(self._scan_recursive(directory))
        else:
            files = list(self._scan_single_level(directory))

        self.logger.info(f"Found {len(files)} supported files")
        return files

    def _scan_recursive(self, directory: Path) -> Generator[Path, None, None]:
        """재귀적 디렉토리 스캔."""
        try:
            for item in directory.rglob('*'):
                if item.is_file() and self._is_supported_file(item):
                    yield item
        except (PermissionError, OSError) as e:
            self.logger.warning(f"Access denied to {directory}: {e}")

    def _scan_single_level(self, directory: Path) -> Generator[Path, None, None]:
        """단일 레벨 디렉토리 스캔."""
        try:
            for item in directory.iterdir():
                if item.is_file() and self._is_supported_file(item):
                    yield item
        except (PermissionError, OSError) as e:
            self.logger.warning(f"Access denied to {directory}: {e}")

    def _is_supported_file(self, file_path: Path) -> bool:
        """지원되는 파일인지 확인."""
        # 확장자 확인
        if file_path.suffix.lower() not in SUPPORTED_EXTENSIONS:
            return False

        # 숨김 파일 제외
        if file_path.name.startswith('.'):
            return False

        # 시스템 파일 제외
        if file_path.name.startswith('~$'):  # 임시 파일
            return False

        return True

    def scan_with_progress(self, directory: Path, recursive: bool = True) -> List[Path]:
        """진행률 콜백과 함께 스캔."""
        files = []
        total_found = 0

        for file_path in self._scan_recursive(directory) if recursive else self._scan_single_level(directory):
            files.append(file_path)
            total_found += 1

            if self.progress_callback and total_found % 100 == 0:
                self.progress_callback(total_found, -1)  # -1은 총 개수 미정

        if self.progress_callback:
            self.progress_callback(total_found, total_found)

        return files
```

## 파일 파싱 패턴

### **애니메이션 파일명 파서**
```python
# ✅ DO: AniVault 파일명 파서 (anitopy + 폴백)
import anitopy
import re
from dataclasses import dataclass
from typing import Optional, Dict, Any
from pathlib import Path

@dataclass
class ParsedAnimeFile:
    """파싱된 애니메이션 파일 정보."""
    file_path: Path
    original_name: str
    title: Optional[str] = None
    season: Optional[int] = None
    episode: Optional[int] = None
    episode_title: Optional[str] = None
    quality: Optional[str] = None
    release_group: Optional[str] = None
    video_codec: Optional[str] = None
    audio_codec: Optional[str] = None
    language: Optional[str] = None
    subtitles: Optional[str] = None
    parsing_method: str = "unknown"
    confidence: float = 0.0

class AniVaultFileParser:
    """AniVault 파일명 파서 - anitopy + 폴백 파서."""

    def __init__(self):
        self.logger = logging.getLogger("pipeline.parser")
        self.anitopy_options = {
            'allowed_delimiters': ' _.&+,|',
            'ignored_strings': ['BD', 'BDRip', 'BluRay', 'WEBRip', 'HDRip']
        }

    def parse_file(self, file_path: Path) -> ParsedAnimeFile:
        """파일명 파싱 - anitopy 우선, 폴백 파서 사용."""
        filename = file_path.stem  # 확장자 제외한 파일명

        parsed = ParsedAnimeFile(
            file_path=file_path,
            original_name=filename
        )

        # 1차: anitopy 파싱 시도
        anitopy_result = self._parse_with_anitopy(filename)
        if anitopy_result and self._validate_anitopy_result(anitopy_result):
            self._apply_anitopy_result(parsed, anitopy_result)
            parsed.parsing_method = "anitopy"
            parsed.confidence = 0.9
            return parsed

        # 2차: 폴백 파서 시도
        fallback_result = self._parse_with_fallback(filename)
        if fallback_result:
            self._apply_fallback_result(parsed, fallback_result)
            parsed.parsing_method = "fallback"
            parsed.confidence = 0.6
            return parsed

        # 3차: 최소한의 정보라도 추출
        self._parse_minimal(parsed, filename)
        parsed.parsing_method = "minimal"
        parsed.confidence = 0.3

        return parsed

    def _parse_with_anitopy(self, filename: str) -> Optional[Dict[str, Any]]:
        """anitopy를 사용한 파싱."""
        try:
            result = anitopy.parse(filename, options=self.anitopy_options)
            return result if result else None
        except Exception as e:
            self.logger.warning(f"Anitopy parsing failed for '{filename}': {e}")
            return None

    def _validate_anitopy_result(self, result: Dict[str, Any]) -> bool:
        """anitopy 결과 검증."""
        # 최소한의 정보가 있는지 확인
        return bool(result.get('anime_title') or result.get('anime_season') or result.get('episode_number'))

    def _apply_anitopy_result(self, parsed: ParsedAnimeFile, result: Dict[str, Any]) -> None:
        """anitopy 결과 적용."""
        parsed.title = result.get('anime_title')
        parsed.season = self._parse_number(result.get('anime_season'))
        parsed.episode = self._parse_number(result.get('episode_number'))
        parsed.episode_title = result.get('episode_title')
        parsed.quality = result.get('video_resolution')
        parsed.release_group = result.get('release_group')
        parsed.video_codec = result.get('video_term')
        parsed.audio_codec = result.get('audio_term')

    def _parse_with_fallback(self, filename: str) -> Optional[Dict[str, Any]]:
        """폴백 파서 - 정규식 기반."""
        # 일반적인 애니메이션 파일명 패턴들
        patterns = [
            # S01E01 형식
            r'(.+?)[_\s]+S(\d{1,2})E(\d{1,3})[_\s]*(.+?)?[_\s]*(\d{3,4}p)?',
            # 시즌 에피소드 형식
            r'(.+?)[_\s]+(\d{1,2})[_\s]+(\d{1,3})[_\s]*(.+?)?[_\s]*(\d{3,4}p)?',
            # 단순 에피소드 형식
            r'(.+?)[_\s]+(\d{1,3})[_\s]*(.+?)?[_\s]*(\d{3,4}p)?',
        ]

        for pattern in patterns:
            match = re.search(pattern, filename, re.IGNORECASE)
            if match:
                groups = match.groups()
                result = {}

                if len(groups) >= 3:
                    result['title'] = groups[0].replace('_', ' ').strip()
                    if len(groups) >= 5:  # S01E01 형식
                        result['season'] = groups[1]
                        result['episode'] = groups[2]
                        result['episode_title'] = groups[3]
                        result['quality'] = groups[4]
                    elif len(groups) >= 4:  # 시즌 에피소드 형식
                        result['season'] = groups[1]
                        result['episode'] = groups[2]
                        result['quality'] = groups[3]
                    else:  # 단순 에피소드 형식
                        result['episode'] = groups[1]
                        result['quality'] = groups[2]

                return result

        return None

    def _apply_fallback_result(self, parsed: ParsedAnimeFile, result: Dict[str, Any]) -> None:
        """폴백 결과 적용."""
        parsed.title = result.get('title')
        parsed.season = self._parse_number(result.get('season'))
        parsed.episode = self._parse_number(result.get('episode'))
        parsed.episode_title = result.get('episode_title')
        parsed.quality = result.get('quality')

    def _parse_minimal(self, parsed: ParsedAnimeFile, filename: str) -> None:
        """최소한의 정보 추출."""
        # 파일명에서 품질 정보 추출
        quality_match = re.search(r'(\d{3,4}p)', filename, re.IGNORECASE)
        if quality_match:
            parsed.quality = quality_match.group(1)

        # 파일명에서 숫자 추출 (에피소드로 추정)
        episode_match = re.search(r'[_\s](\d{1,3})[_\s]', filename)
        if episode_match:
            parsed.episode = self._parse_number(episode_match.group(1))

        # 나머지를 제목으로 사용
        clean_name = re.sub(r'[_\s]*\d{3,4}p[_\s]*', '', filename)
        clean_name = re.sub(r'[_\s]*\d{1,3}[_\s]*', '', clean_name)
        parsed.title = clean_name.replace('_', ' ').strip()

    def _parse_number(self, value: Any) -> Optional[int]:
        """숫자 파싱."""
        if value is None:
            return None

        try:
            return int(str(value))
        except (ValueError, TypeError):
            return None
```

## 파일 그룹화 패턴

### **애니메이션 파일 그룹화**
```python
# ✅ DO: rapidfuzz 기반 파일 그룹화
from rapidfuzz import fuzz, process
from typing import List, Dict, Set
from collections import defaultdict

@dataclass
class AnimeGroup:
    """애니메이션 파일 그룹."""
    title: str
    files: List[ParsedAnimeFile]
    metadata: Optional[Dict[str, Any]] = None

    def add_file(self, file: ParsedAnimeFile) -> None:
        """파일 추가."""
        self.files.append(file)

    def get_season_files(self, season: int) -> List[ParsedAnimeFile]:
        """특정 시즌 파일들 반환."""
        return [f for f in self.files if f.season == season]

    def get_episode_files(self, episode: int) -> List[ParsedAnimeFile]:
        """특정 에피소드 파일들 반환."""
        return [f for f in self.files if f.episode == episode]

    def has_duplicates(self) -> bool:
        """중복 파일 존재 여부."""
        episodes = [f.episode for f in self.files if f.episode is not None]
        return len(episodes) != len(set(episodes))

class AniVaultFileGrouper:
    """AniVault 파일 그룹화 - rapidfuzz 기반."""

    def __init__(self,
                 similarity_threshold: int = 85,
                 duplicate_handling: str = "keep_best"):
        self.similarity_threshold = similarity_threshold
        self.duplicate_handling = duplicate_handling
        self.logger = logging.getLogger("pipeline.grouper")

    def group_files(self, parsed_files: List[ParsedAnimeFile]) -> List[AnimeGroup]:
        """파일들을 그룹화."""
        if not parsed_files:
            return []

        self.logger.info(f"Grouping {len(parsed_files)} parsed files")

        # 1단계: 제목별 그룹화
        title_groups = self._group_by_title_similarity(parsed_files)

        # 2단계: 중복 처리
        final_groups = []
        for title, files in title_groups.items():
            group = AnimeGroup(title=title, files=files)
            self._handle_duplicates(group)
            final_groups.append(group)

        self.logger.info(f"Created {len(final_groups)} groups")
        return final_groups

    def _group_by_title_similarity(self, files: List[ParsedAnimeFile]) -> Dict[str, List[ParsedAnimeFile]]:
        """제목 유사도 기반 그룹화."""
        groups = defaultdict(list)
        processed = set()

        for i, file in enumerate(files):
            if i in processed:
                continue

            if not file.title:
                # 제목이 없는 파일은 개별 그룹으로
                groups[f"unknown_{i}"].append(file)
                continue

            # 현재 파일과 유사한 파일들 찾기
            similar_files = [file]
            processed.add(i)

            for j, other_file in enumerate(files[i+1:], i+1):
                if j in processed or not other_file.title:
                    continue

                similarity = fuzz.ratio(file.title.lower(), other_file.title.lower())
                if similarity >= self.similarity_threshold:
                    similar_files.append(other_file)
                    processed.add(j)

            # 가장 적절한 그룹명 선택
            group_title = self._select_best_title([f.title for f in similar_files if f.title])
            groups[group_title].extend(similar_files)

        return dict(groups)

    def _select_best_title(self, titles: List[str]) -> str:
        """가장 적절한 제목 선택."""
        if not titles:
            return "unknown"

        # 가장 긴 제목을 선택 (더 많은 정보 포함)
        return max(titles, key=len)

    def _handle_duplicates(self, group: AnimeGroup) -> None:
        """중복 파일 처리."""
        if not group.has_duplicates():
            return

        self.logger.info(f"Handling duplicates for group: {group.title}")

        # 에피소드별로 그룹화
        episode_groups = defaultdict(list)
        for file in group.files:
            if file.episode is not None:
                episode_groups[file.episode].append(file)

        # 각 에피소드별 중복 처리
        final_files = []
        for episode, files in episode_groups.items():
            if len(files) == 1:
                final_files.append(files[0])
            else:
                # 중복 처리 전략 적용
                selected_file = self._select_best_duplicate(files)
                final_files.append(selected_file)

                self.logger.info(f"Selected {selected_file.file_path.name} for episode {episode}")

        group.files = final_files

    def _select_best_duplicate(self, files: List[ParsedAnimeFile]) -> ParsedAnimeFile:
        """중복 파일 중 최적 선택."""
        if self.duplicate_handling == "keep_best":
            # 품질 기준으로 선택
            quality_priority = {'1080p': 3, '720p': 2, '480p': 1}

            def quality_score(file: ParsedAnimeFile) -> int:
                if not file.quality:
                    return 0
                return quality_priority.get(file.quality, 0)

            return max(files, key=quality_score)

        elif self.duplicate_handling == "keep_largest":
            # 파일 크기 기준으로 선택
            return max(files, key=lambda f: f.file_path.stat().st_size)

        else:  # keep_first
            # 첫 번째 파일 선택
            return files[0]
```

## 안티패턴 및 금지사항

### **❌ DON'T: 잘못된 파일 처리 패턴**
```python
# ❌ DON'T: 인코딩 미지정
def bad_file_read():
    with open("file.txt", "r") as f:  # ❌ 인코딩 미지정
        content = f.read()

# ❌ DON'T: 모든 파일 스캔
def bad_scan_all():
    for file in directory.rglob("*"):  # ❌ 모든 파일 스캔
        process_file(file)

# ❌ DON'T: 파싱 실패 무시
def bad_parse_ignore():
    try:
        result = parse_filename(filename)
    except Exception:
        return None  # ❌ 파싱 실패 무시
```

### **✅ DO: 올바른 파일 처리 패턴**
```python
# ✅ DO: UTF-8 강제
def good_file_read():
    with open("file.txt", "r", encoding="utf-8") as f:  # ✅ UTF-8 강제
        content = f.read()

# ✅ DO: 확장자 필터링
def good_scan_filtered():
    for file in directory.rglob("*"):
        if file.suffix.lower() in SUPPORTED_EXTENSIONS:  # ✅ 확장자 필터링
            process_file(file)

# ✅ DO: 파싱 실패 처리
def good_parse_handling():
    try:
        result = parse_filename(filename)
        return result
    except Exception as e:
        logger.warning(f"Parsing failed for {filename}: {e}")  # ✅ 로깅
        return create_minimal_result(filename)  # ✅ 폴백
```

## 관련 룰 참조

- **성능**: [performance.mdc](mdc:.cursor/rules/performance.mdc)
- **에러 처리**: [error_handling.mdc](mdc:.cursor/rules/error_handling.mdc)
- **로깅**: [logging.mdc](mdc:.cursor/rules/logging.mdc)
- **테스트**: [testing.mdc](mdc:.cursor/rules/testing.mdc)
