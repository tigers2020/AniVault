---
description: Comprehensive Python development standards and best practices
globs: src/**/*.py, tests/**/*.py, scripts/**/*.py
alwaysApply: true
priority: 3
---

# Python Development Standards

## í•µì‹¬ ì›ì¹™

- **íƒ€ì… íŒíŠ¸ í•„ìˆ˜**: ëª¨ë“  í•¨ìˆ˜, ë©”ì„œë“œ, ë³€ìˆ˜ì— íƒ€ì… íŒíŠ¸ ì ìš©
- **Google/NumPy ìŠ¤íƒ€ì¼ ë…ìŠ¤íŠ¸ë§**: í•¨ìˆ˜ ì •ì˜ í›„ ë…ìŠ¤íŠ¸ë§ ì‘ì„±
- **í•¨ìˆ˜ í¬ê¸° ì œí•œ**: 50-80ì¤„ ì´í•˜, ë‹¨ì¼ ì±…ì„ ì›ì¹™
- **ì…ë ¥ ê²€ì¦**: ê²½ê³„ì—ì„œ ì…ë ¥ê°’ ê²€ì¦, êµ¬ì²´ì  ì˜ˆì™¸ ë°œìƒ
- **ë¹„ë™ê¸° íŒ¨í„´**: asyncio ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬
- **One Source of Truth**: íƒ€ì…, ìƒìˆ˜, ì—ëŸ¬ ì½”ë“œëŠ” ë‹¨ì¼ ìœ„ì¹˜ì—ì„œë§Œ ì •ì˜
- **Magic Values Elimination**: í•˜ë“œì½”ë”©ëœ ê°’ì€ ìƒìˆ˜ë¡œ ì¶”ì¶œ

## íƒ€ì… íŒíŠ¸ íŒ¨í„´

### **âœ… DO: ì™„ì „í•œ íƒ€ì… íŒíŠ¸**
```python
from typing import List, Dict, Optional, Union, Any, Callable
from pathlib import Path
from dataclasses import dataclass

@dataclass
class AnimeFile:
    """ì• ë‹ˆë©”ì´ì…˜ íŒŒì¼ ì •ë³´."""
    path: Path
    series_name: str
    episode_number: Optional[int]
    quality: Optional[str]

def process_anime_files(
    file_paths: List[Path],
    callback: Optional[Callable[[AnimeFile], None]] = None
) -> Dict[str, List[AnimeFile]]:
    """ì• ë‹ˆë©”ì´ì…˜ íŒŒì¼ë“¤ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

    Args:
        file_paths: ì²˜ë¦¬í•  íŒŒì¼ ê²½ë¡œ ëª©ë¡
        callback: ê° íŒŒì¼ ì²˜ë¦¬ í›„ í˜¸ì¶œí•  ì½œë°± í•¨ìˆ˜

    Returns:
        ì‹œë¦¬ì¦ˆë³„ë¡œ ê·¸ë£¹í™”ëœ íŒŒì¼ ì •ë³´ ë”•ì…”ë„ˆë¦¬

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œ
        ValueError: íŒŒì¼ í˜•ì‹ì´ ì§€ì›ë˜ì§€ ì•Šì„ ë•Œ
    """
    if not file_paths:
        raise ValueError("íŒŒì¼ ê²½ë¡œ ëª©ë¡ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")

    results: Dict[str, List[AnimeFile]] = {}
    # êµ¬í˜„...
    return results
```

### **âŒ DON'T: íƒ€ì… íŒíŠ¸ ëˆ„ë½**
```python
# âŒ BAD: íƒ€ì… íŒíŠ¸ ì—†ìŒ
def process_files(files, callback=None):
    results = {}
    # êµ¬í˜„...
    return results
```

## ë…ìŠ¤íŠ¸ë§ íŒ¨í„´

### **âœ… DO: Google ìŠ¤íƒ€ì¼ ë…ìŠ¤íŠ¸ë§**
```python
def parse_anime_filename(filename: str) -> Optional[AnimeFile]:
    """anitopyë¥¼ ì‚¬ìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ íŒŒì¼ëª…ì„ íŒŒì‹±í•©ë‹ˆë‹¤.

    Args:
        filename: íŒŒì‹±í•  íŒŒì¼ëª… (ê²½ë¡œ í¬í•¨ ê°€ëŠ¥)

    Returns:
        íŒŒì‹±ëœ ì• ë‹ˆë©”ì´ì…˜ íŒŒì¼ ì •ë³´, ì‹¤íŒ¨ì‹œ None

    Example:
        >>> parse_anime_filename("Attack on Titan S01E01.mkv")
        AnimeFile(series_name="Attack on Titan", episode=1, ...)
    """
    try:
        import anitopy
        parsed = anitopy.parse(filename)
        return AnimeFile(
            path=Path(filename),
            series_name=parsed.get('anime_title', ''),
            episode_number=parsed.get('episode_number'),
            quality=parsed.get('video_quality')
        )
    except Exception:
        return None
```

## ë¹„ë™ê¸° íŒ¨í„´

### **âœ… DO: asyncio ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬**
```python
import asyncio
import aiohttp
from typing import List, Dict, Any

class TMDBAsyncClient:
    """TMDB API ë¹„ë™ê¸° í´ë¼ì´ì–¸íŠ¸."""

    def __init__(self, api_key: str, base_url: str = "https://api.themoviedb.org/3"):
        self.api_key = api_key
        self.base_url = base_url
        self.session: Optional[aiohttp.ClientSession] = None

    async def __aenter__(self) -> 'TMDBAsyncClient':
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì§„ì…."""
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì¢…ë£Œ."""
        if self.session:
            await self.session.close()

    async def search_anime(self, query: str) -> List[Dict[str, Any]]:
        """ì• ë‹ˆë©”ì´ì…˜ ê²€ìƒ‰."""
        if not self.session:
            raise RuntimeError("ì„¸ì…˜ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")

        url = f"{self.base_url}/search/tv"
        params = {
            'api_key': self.api_key,
            'query': query,
            'language': 'ko-KR'
        }

        async with self.session.get(url, params=params) as response:
            response.raise_for_status()
            data = await response.json()
            return data.get('results', [])
```

## One Source of Truth (ë‹¨ì¼ ì§„ì‹¤ì˜ ì›ì²œ)

### **âœ… DO: ì¤‘ì•™ ì§‘ì¤‘ì‹ ì •ì˜**
```python
# src/shared/constants/__init__.py
from enum import Enum
from typing import Dict, List

class FileFormats(str, Enum):
    """ì§€ì›ë˜ëŠ” íŒŒì¼ í˜•ì‹."""
    MKV = "mkv"
    MP4 = "mp4"
    AVI = "avi"
    MOV = "mov"
    WMV = "wmv"
    FLV = "flv"
    WEBM = "webm"
    M4V = "m4v"

class AnimeStatus(str, Enum):
    """ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ."""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"

class APIConfig:
    """API ì„¤ì • ìƒìˆ˜."""
    BASE_URL = "https://api.themoviedb.org/3"
    TIMEOUT_SECONDS = 30
    MAX_RETRIES = 3
    RATE_LIMIT_PER_SECOND = 50
    CACHE_TTL_HOURS = 24

class FileLimits:
    """íŒŒì¼ ì œí•œ ìƒìˆ˜."""
    MAX_FILENAME_LENGTH = 255
    MAX_FILE_SIZE_MB = 1024 * 1024  # 1GB
    SUPPORTED_EXTENSIONS = [fmt.value for fmt in FileFormats]
```

### **âœ… DO: Importí•˜ì—¬ ì‚¬ìš©**
```python
# src/anivault/core/parser.py
from anivault.shared.constants import FileFormats, APIConfig, FileLimits

def is_supported_file(file_path: Path) -> bool:
    """ì§€ì›ë˜ëŠ” íŒŒì¼ì¸ì§€ í™•ì¸."""
    return file_path.suffix.lower() in FileLimits.SUPPORTED_EXTENSIONS

def get_api_timeout() -> int:
    """API íƒ€ì„ì•„ì›ƒ ì„¤ì • ë°˜í™˜."""
    return APIConfig.TIMEOUT_SECONDS
```

### **âŒ DON'T: ì¤‘ë³µ ì •ì˜**
```python
# âŒ BAD: ì—¬ëŸ¬ íŒŒì¼ì—ì„œ ë™ì¼í•œ ìƒìˆ˜ ì¬ì •ì˜
# file1.py
SUPPORTED_FORMATS = ['.mkv', '.mp4', '.avi']

# file2.py
SUPPORTED_FORMATS = ['.mkv', '.mp4', '.avi']  # âŒ ì¤‘ë³µ!
```

## Single Responsibility Principle (ë‹¨ì¼ ì±…ì„ ì›ì¹™)

### **âœ… DO: ì±…ì„ë³„ í•¨ìˆ˜ ë¶„ë¦¬**
```python
# src/anivault/core/parser.py
class AnimeParser:
    """ì• ë‹ˆë©”ì´ì…˜ íŒŒì¼ íŒŒì„œ - ë‹¨ì¼ ì±…ì„: íŒŒì¼ëª… íŒŒì‹±."""

    def __init__(self):
        self._anitopy = None

    def _get_anitopy(self):
        """anitopy ì¸ìŠ¤í„´ìŠ¤ ì§€ì—° ë¡œë”©."""
        if self._anitopy is None:
            import anitopy
            self._anitopy = anitopy
        return self._anitopy

    def parse_filename(self, filename: str) -> Optional[Dict[str, Any]]:
        """íŒŒì¼ëª… íŒŒì‹± - ë‹¨ì¼ ì±…ì„: íŒŒì¼ëª… íŒŒì‹±ë§Œ."""
        try:
            anitopy = self._get_anitopy()
            return anitopy.parse(filename)
        except Exception as e:
            logger.error(f"íŒŒì¼ëª… íŒŒì‹± ì‹¤íŒ¨: {filename}, {e}")
            return None

# src/anivault/core/validator.py
class FileValidator:
    """íŒŒì¼ ê²€ì¦ê¸° - ë‹¨ì¼ ì±…ì„: íŒŒì¼ ê²€ì¦ë§Œ."""

    def validate_file_path(self, file_path: Path) -> None:
        """íŒŒì¼ ê²½ë¡œ ê²€ì¦."""
        if not file_path.exists():
            raise FileNotFoundError(f"íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}")

        if not file_path.is_file():
            raise ValueError(f"íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {file_path}")

    def validate_file_size(self, file_path: Path) -> None:
        """íŒŒì¼ í¬ê¸° ê²€ì¦."""
        size_mb = file_path.stat().st_size / (1024 * 1024)
        if size_mb > FileLimits.MAX_FILE_SIZE_MB / (1024 * 1024):
            raise ValueError(f"íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: {size_mb:.1f}MB")
```

### **âŒ DON'T: ê±°ëŒ€í•œ í•¨ìˆ˜**
```python
# âŒ BAD: ëª¨ë“  ê²ƒì„ í•˜ëŠ” ê±°ëŒ€í•œ í•¨ìˆ˜
def process_anime_directory(directory, api_key, output_dir):
    """ë””ë ‰í† ë¦¬ ìŠ¤ìº”, íŒŒì‹±, API í˜¸ì¶œ, ê²€ì¦, ì •ë¦¬ë¥¼ ëª¨ë‘ ì²˜ë¦¬"""
    # 200ì¤„ ì´ìƒì˜ ì½”ë“œ...
    # ìŠ¤ìº” ë¡œì§
    # íŒŒì‹± ë¡œì§
    # API í˜¸ì¶œ ë¡œì§
    # ê²€ì¦ ë¡œì§
    # ì •ë¦¬ ë¡œì§
    # ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§
    # ë¡œê¹… ë¡œì§
```

## Magic Values Elimination (ë§¤ì§ ê°’ ì œê±°)

### **âœ… DO: ìƒìˆ˜í™”**
```python
# src/anivault/shared/constants/matching.py
class MatchingConfig:
    """ë§¤ì¹­ ì„¤ì • ìƒìˆ˜."""
    MIN_CONFIDENCE_SCORE = 0.7
    MAX_SEARCH_RESULTS = 10
    CACHE_EXPIRY_DAYS = 30
    RETRY_DELAY_SECONDS = 1
    MAX_RETRY_ATTEMPTS = 3

class LogLevels:
    """ë¡œê·¸ ë ˆë²¨ ìƒìˆ˜."""
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

# ì‚¬ìš© ì˜ˆì‹œ
def search_anime(query: str, min_confidence: float = MatchingConfig.MIN_CONFIDENCE_SCORE) -> List[Dict]:
    """ì• ë‹ˆë©”ì´ì…˜ ê²€ìƒ‰."""
    if min_confidence < 0 or min_confidence > 1:
        raise ValueError(f"ì‹ ë¢°ë„ ì ìˆ˜ëŠ” 0-1 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤: {min_confidence}")

    # ê²€ìƒ‰ ë¡œì§...
```

### **âŒ DON'T: ë§¤ì§ ê°’ í•˜ë“œì½”ë”©**
```python
# âŒ BAD: ë§¤ì§ ê°’ ì§ì ‘ ì‚¬ìš©
def search_anime(query):
    if confidence < 0.7:  # âŒ ë§¤ì§ ë„˜ë²„
        return None

    for i in range(3):  # âŒ ë§¤ì§ ë„˜ë²„
        try:
            # API í˜¸ì¶œ
            pass
        except:
            time.sleep(1)  # âŒ ë§¤ì§ ë„˜ë²„
```

## ë„¤ì´ë° ì»¨ë²¤ì…˜

### **ê¸ˆì§€ëœ ìš©ì–´**
- **"unified" ì‚¬ìš© ê¸ˆì§€**: ë©”ì„œë“œëª…, ë³€ìˆ˜ëª…, ì£¼ì„ì—ì„œ "unified" ì‚¬ìš© ê¸ˆì§€
  - âŒ DON'T: `search_unified()`, `unified_strategies`, `unified_search`
  - âœ… DO: `search()`, `search_strategies`, `search_method`

### **âœ… DO: ëª…í™•í•˜ê³  ê°„ê²°í•œ ë„¤ì´ë°**
```python
# âœ… GOOD: ëª…í™•í•˜ê³  ê°„ê²°í•¨
def search(self, query: str) -> Optional[SearchResult]:
    """ì¬ê·€ì  ì „ëµìœ¼ë¡œ TVì™€ Movie ê²€ìƒ‰ì„ ëª¨ë‘ ì‹œë„í•˜ëŠ” ê²€ìƒ‰."""
    search_strategies = [SearchStrategy.ORIGINAL, SearchStrategy.NORMALIZED]
    search_result = self.recursive_search(query, strategies=search_strategies)
    return search_result

# âŒ BAD: ì¤‘ë³µì ì´ê³  ì¥í™©í•¨
def search_unified(self, query: str) -> Optional[SearchResult]:
    """ì¬ê·€ì  ì „ëµìœ¼ë¡œ TVì™€ Movie ê²€ìƒ‰ì„ ëª¨ë‘ ì‹œë„í•˜ëŠ” í†µí•© ê²€ìƒ‰."""
    unified_search_strategies = [SearchStrategy.ORIGINAL, SearchStrategy.NORMALIZED]
    unified_search_result = self.recursive_search(query, strategies=unified_search_strategies)
    return unified_search_result
```

## ë„êµ¬ ì„¤ì •

### **Pre-commit ì„¤ì •**
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.12.1
    hooks:
      - id: black
        language_version: python3.9

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.8
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies: [types-requests, types-PyYAML]
```

### **pyproject.toml ì„¤ì •**
```toml
[tool.black]
line-length = 88
target-version = ['py39']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.ruff]
target-version = "py39"
line-length = 88
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = [
    "E501",  # line too long, handled by black
    "B008",  # do not perform function calls in argument defaults
    "C901",  # too complex
]

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
```

## AI ì½”ë“œ í’ˆì§ˆ ê²€ì¦

### **ìë™ ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸**
```python
# scripts/validate_ai_quality.py
import ast
import os
from typing import List, Dict, Any

class AICodeQualityValidator:
    """AI ì½”ë“œ í’ˆì§ˆ ê²€ì¦ê¸°."""

    def validate_project(self, src_dir: str = "src") -> Dict[str, List[str]]:
        """í”„ë¡œì íŠ¸ ì „ì²´ í’ˆì§ˆ ê²€ì¦."""
        issues = {
            "duplicate_definitions": [],
            "magic_values": [],
            "long_functions": [],
            "missing_type_hints": []
        }

        for root, dirs, files in os.walk(src_dir):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    self._validate_file(file_path, issues)

        return issues

    def _validate_file(self, file_path: str, issues: Dict[str, List[str]]):
        """íŒŒì¼ ê²€ì¦."""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        tree = ast.parse(content)

        # ì¤‘ë³µ ì •ì˜ ê²€ì‚¬
        self._check_duplicate_definitions(file_path, tree, issues)

        # ë§¤ì§ ê°’ ê²€ì‚¬
        self._check_magic_values(file_path, content, issues)

        # í•¨ìˆ˜ ê¸¸ì´ ê²€ì‚¬
        self._check_function_length(file_path, tree, issues)

        # íƒ€ì… íŒíŠ¸ ê²€ì‚¬
        self._check_type_hints(file_path, tree, issues)
```

### **Pre-commit í›…**
```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "ğŸ” Running AI Code Quality Validation..."

# ë§¤ì§ ê°’ íƒì§€
magic_strings=$(find src -name "*.py" -exec grep -n "\"pending\"\|\"processing\"\|\"completed\"" {} \;)
if [ ! -z "$magic_strings" ]; then
    echo "âŒ ERROR: Magic strings found! Use constants instead."
    echo "$magic_strings"
    exit 1
fi

# í•¨ìˆ˜ ê¸¸ì´ ê²€ì‚¬
python3 -c "
import ast
import os

def check_function_length(file_path, max_lines=80):
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    tree = ast.parse(content)
    issues = []

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            start_line = node.lineno
            end_line = getattr(node, 'end_lineno', start_line)
            function_length = end_line - start_line + 1

            if function_length > max_lines:
                issues.append((node.name, start_line, function_length))

    return issues

# ëª¨ë“  Python íŒŒì¼ ê²€ì‚¬
for file in \$(find src -name '*.py'); do
    issues = check_function_length(file)
    if issues:
        print(f'âŒ Functions too long in {file}:')
        for func_name, line_num, length in issues:
            print(f'  {func_name} (line {line_num}): {length} lines')
        exit(1)

print('âœ… AI Code Quality validation passed!')
"

if [ $? -eq 0 ]; then
    echo "âœ… AI Code Quality validation passed!"
    exit 0
else
    echo "âŒ AI Code Quality validation failed!"
    exit 1
fi
```

## ê´€ë ¨ ê·œì¹™

- **ì‹œìŠ¤í…œ í‘œì¤€**: [system_standards.mdc](mdc:.cursor/rules/system_standards.mdc)
- **í’ˆì§ˆ ë³´ì¦**: [quality_assurance.mdc](mdc:.cursor/rules/quality_assurance.mdc)
- **íŒŒì¼ ì²˜ë¦¬**: [file_processing.mdc](mdc:.cursor/rules/file_processing.mdc)
